query AuraGlobalStats{
  global(id: "global") {
    id
    aura
    auraTotalSupply
    auraBalTotalSupply
    auraMaxSupply
    auraReductionPerCliff
    auraTotalCliffs
  }
  masterChefs {
    id
    endBlock
    startBlock
    totalAllocPoint
    rewardPerBlock
  }
  tokens(first: 1000) {
    ...AllToken
  }
}

#Transactions for AuraBAL mints
query AuraBalMintTransactions($startTimestamp: Int!) {
  auraBalMintTransactions(
    where: {timestamp_gt: $startTimestamp}
    first: 800
    orderBy: timestamp
    orderDirection: asc
  ) {
    timestamp
    amount
  }
}

#Transactions for AuraBAL
query AuraBalTransactions {
  auraBalMintTransactions(
    where: {amount_gte: "100000000000000000000"}
    first: 100
    orderBy: timestamp
    orderDirection: desc
  ) {
    timestamp
    amount
    hash
    account {
      id
    }
  }
  vaultHarvestTransactions(first: 50, orderBy: timestamp, orderDirection: desc) {
    timestamp
    harvested
    hash
    sender
  }
  vaultDepositTransactions(first: 250, orderBy: timestamp, orderDirection: desc) {
    timestamp
    assets
    shares
    hash
    vaultAccount {
      account {
        id
      }
    }
  }
}

#Leaderboard of accounts for a specific Aura Pool (not balancer pool!)
query PoolLeaderboard($poolId: ID!) {
  leaderboard: pool(id: $poolId) {
    accounts(
      first: 1000
      where: {staked_gt: 1000000000000000000}
      orderBy: staked
      orderDirection: desc
    ) {
      staked
      account {
        id
      }
    }
    totalStaked
  }
}

#TODO: Figure out what vault ID is!
query VaultLeaderboard($vaultId: ID!) {
  leaderboard: vault(id: $vaultId) {
    accounts(
      first: 1000
      where: {shares_gt: 1000000000000000000}
      orderBy: shares
      orderDirection: desc
    ) {
      shares
      account {
        id
      }
    }
    totalSupply
  }
}


# TODO: Refactor Global Aura stats query
query Aura($accountId: String = "", $hasAccount: Boolean = false) {
  ...Block
  auraBal: pool(id: "auraBal") {
    ...AllPool
    rewardData {
      ...AllPoolRewardData
      queuedRewards
    }
    accounts(where: {account: $accountId}) @include(if: $hasAccount) {
      ...AllPoolAccount
    }
  }
  factoryPools: pools(where: {isFactoryPool: true}) {
    ...AllPool
    rewardData {
      ...AllPoolRewardData
      queuedRewards
    }
    accounts(where: {account: $accountId}) @include(if: $hasAccount) {
      ...AllPoolAccount
    }
  }
  vault(id: "0xfaa2ed111b4f580fcb85c48e6dc6782dc5fcd7a6") {
    id
    decimals
    name
    symbol
    strategy
    totalSupply
    totalUnderlying
    underlying {
      ...AllToken
    }
    asset {
      ...AllToken
    }
    rewardData {
      id
      token {
        ...AllToken
      }
      periodFinish
      lastUpdateTime
      rewardPerTokenStored
      rewardRate
      queuedRewards
    }
    accounts(where: {account: $accountId}) @include(if: $hasAccount) {
      id
      shares
      rewards {
        id
        rewardToken {
          ...AllToken
        }
        rewardPerTokenPaid
        rewards
      }
    }
  }
}

fragment Block on Query {
  _meta {
    block {
      number
    }
  }
}

fragment AllPool on Pool {
  id
  depositToken {
    ...AllToken
  }
  lpToken {
    ...AllToken
  }
  isFactoryPool
  factoryPoolData {
    id
    addedAt
    isShutdown
    stash
    gauge
  }
  gauge {
    id
    balance
    totalSupply
    workingSupply
  }
  rewardPool
  totalSupply
  totalStaked
  __typename
}

fragment AllToken on Token {
  id
  decimals
  symbol
  name

}

fragment AllPoolRewardData on PoolRewardData {
  id
  token {
    ...AllToken
  }
  periodFinish
  lastUpdateTime
  rewardPerTokenStored
  rewardRate
}

fragment AllPoolAccount on PoolAccount {
  id
  staked
  rewards {
    ...AllPoolAccountRewards
  }
}

fragment AllPoolAccountRewards on PoolAccountRewards {
  id
  rewards
  rewardPerTokenPaid
  rewardToken {
    ...AllToken
  }
}