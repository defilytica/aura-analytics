"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""
Defined a Subgraph ID for an object type
"""
directive @subgraphId(id: String!) on OBJECT

type Account {
  auraBalMintTransactions(
    first: Int = 100
    orderBy: AuraBalMintTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: AuraBalMintTransaction_filter
  ): [AuraBalMintTransaction!]!
  auraLockerAccount: AuraLockerAccount

  """
  Address
  """
  id: ID!
  merkleDropClaims(
    first: Int = 100
    orderBy: MerkleDropClaim_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: MerkleDropClaim_filter
  ): [MerkleDropClaim!]!
  poolAccounts(
    first: Int = 100
    orderBy: PoolAccount_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: PoolAccount_filter
  ): [PoolAccount!]!
  vaultAccounts(
    first: Int = 100
    orderBy: VaultAccount_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: VaultAccount_filter
  ): [VaultAccount!]!
}

input Account_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  auraBalMintTransactions_: AuraBalMintTransaction_filter
  auraLockerAccount: String
  auraLockerAccount_: AuraLockerAccount_filter
  auraLockerAccount_contains: String
  auraLockerAccount_contains_nocase: String
  auraLockerAccount_ends_with: String
  auraLockerAccount_ends_with_nocase: String
  auraLockerAccount_gt: String
  auraLockerAccount_gte: String
  auraLockerAccount_in: [String!]
  auraLockerAccount_lt: String
  auraLockerAccount_lte: String
  auraLockerAccount_not: String
  auraLockerAccount_not_contains: String
  auraLockerAccount_not_contains_nocase: String
  auraLockerAccount_not_ends_with: String
  auraLockerAccount_not_ends_with_nocase: String
  auraLockerAccount_not_in: [String!]
  auraLockerAccount_not_starts_with: String
  auraLockerAccount_not_starts_with_nocase: String
  auraLockerAccount_starts_with: String
  auraLockerAccount_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  merkleDropClaims_: MerkleDropClaim_filter
  poolAccounts_: PoolAccount_filter
  vaultAccounts_: VaultAccount_filter
}

enum Account_orderBy {
  auraBalMintTransactions
  auraLockerAccount
  id
  merkleDropClaims
  poolAccounts
  vaultAccounts
}

type AmpUpdate {
  endAmp: BigInt!
  endTimestamp: BigInt!
  id: ID!
  poolId: Pool!
  scheduledTimestamp: Int!
  startAmp: BigInt!
  startTimestamp: BigInt!
}

input AmpUpdate_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [AmpUpdate_filter]
  endAmp: BigInt
  endAmp_gt: BigInt
  endAmp_gte: BigInt
  endAmp_in: [BigInt!]
  endAmp_lt: BigInt
  endAmp_lte: BigInt
  endAmp_not: BigInt
  endAmp_not_in: [BigInt!]
  endTimestamp: BigInt
  endTimestamp_gt: BigInt
  endTimestamp_gte: BigInt
  endTimestamp_in: [BigInt!]
  endTimestamp_lt: BigInt
  endTimestamp_lte: BigInt
  endTimestamp_not: BigInt
  endTimestamp_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [AmpUpdate_filter]
  poolId: String
  poolId_: Pool_filter
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_gt: String
  poolId_gte: String
  poolId_in: [String!]
  poolId_lt: String
  poolId_lte: String
  poolId_not: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  poolId_not_in: [String!]
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  scheduledTimestamp: Int
  scheduledTimestamp_gt: Int
  scheduledTimestamp_gte: Int
  scheduledTimestamp_in: [Int!]
  scheduledTimestamp_lt: Int
  scheduledTimestamp_lte: Int
  scheduledTimestamp_not: Int
  scheduledTimestamp_not_in: [Int!]
  startAmp: BigInt
  startAmp_gt: BigInt
  startAmp_gte: BigInt
  startAmp_in: [BigInt!]
  startAmp_lt: BigInt
  startAmp_lte: BigInt
  startAmp_not: BigInt
  startAmp_not_in: [BigInt!]
  startTimestamp: BigInt
  startTimestamp_gt: BigInt
  startTimestamp_gte: BigInt
  startTimestamp_in: [BigInt!]
  startTimestamp_lt: BigInt
  startTimestamp_lte: BigInt
  startTimestamp_not: BigInt
  startTimestamp_not_in: [BigInt!]
}

enum AmpUpdate_orderBy {
  endAmp
  endTimestamp
  id
  poolId
  poolId__address
  poolId__alpha
  poolId__amp
  poolId__baseToken
  poolId__beta
  poolId__c
  poolId__createTime
  poolId__dSq
  poolId__delta
  poolId__epsilon
  poolId__expiryTime
  poolId__factory
  poolId__holdersCount
  poolId__id
  poolId__isInRecoveryMode
  poolId__isPaused
  poolId__lambda
  poolId__lastPostJoinExitInvariant
  poolId__lowerTarget
  poolId__mainIndex
  poolId__managementFee
  poolId__name
  poolId__oracleEnabled
  poolId__owner
  poolId__poolType
  poolId__poolTypeVersion
  poolId__principalToken
  poolId__protocolAumFeeCache
  poolId__protocolId
  poolId__protocolSwapFeeCache
  poolId__protocolYieldFeeCache
  poolId__root3Alpha
  poolId__s
  poolId__sqrtAlpha
  poolId__sqrtBeta
  poolId__strategyType
  poolId__swapEnabled
  poolId__swapFee
  poolId__swapsCount
  poolId__symbol
  poolId__tauAlphaX
  poolId__tauAlphaY
  poolId__tauBetaX
  poolId__tauBetaY
  poolId__totalLiquidity
  poolId__totalShares
  poolId__totalSwapFee
  poolId__totalSwapVolume
  poolId__totalWeight
  poolId__tx
  poolId__u
  poolId__unitSeconds
  poolId__upperTarget
  poolId__v
  poolId__w
  poolId__wrappedIndex
  poolId__z
  scheduledTimestamp
  startAmp
  startTimestamp
}

type AuraBalMintTransaction {
  account: Account!
  amount: BigInt!
  hash: Bytes!
  id: ID!
  timestamp: Int!
}

input AuraBalMintTransaction_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: String
  account_: Account_filter
  account_contains: String
  account_contains_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_gt: String
  account_gte: String
  account_in: [String!]
  account_lt: String
  account_lte: String
  account_not: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_not_in: [String!]
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  hash: Bytes
  hash_contains: Bytes
  hash_in: [Bytes!]
  hash_not: Bytes
  hash_not_contains: Bytes
  hash_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
}

enum AuraBalMintTransaction_orderBy {
  account
  amount
  hash
  id
  timestamp
}

type AuraLocker {
  accounts(
    first: Int = 100
    orderBy: AuraLockerAccount_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: AuraLockerAccount_filter
  ): [AuraLockerAccount!]!
  address: Bytes!
  delegateChangedTransactions(
    first: Int = 100
    orderBy: LockerDelegateChangedTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LockerDelegateChangedTransaction_filter
  ): [LockerDelegateChangedTransaction!]!

  """
  Singleton: "AuraLocker"
  """
  id: ID!
  isShutdown: Boolean!
  kickRewardTransactions(
    first: Int = 100
    orderBy: LockerKickRewardTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LockerKickRewardTransaction_filter
  ): [LockerKickRewardTransaction!]!
  lockedSupply: BigInt!
  rewardData(
    first: Int = 100
    orderBy: AuraLockerRewardData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: AuraLockerRewardData_filter
  ): [AuraLockerRewardData!]!
  rewardPaidTransactions(
    first: Int = 100
    orderBy: LockerRewardPaidTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LockerRewardPaidTransaction_filter
  ): [LockerRewardPaidTransaction!]!
  stakedTransactions(
    first: Int = 100
    orderBy: LockerStakedTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LockerStakedTransaction_filter
  ): [LockerStakedTransaction!]!
  totalSupply: BigInt!
  withdrawnTransactions(
    first: Int = 100
    orderBy: LockerWithdrawnTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LockerWithdrawnTransaction_filter
  ): [LockerWithdrawnTransaction!]!
}

type AuraLockerAccount {
  account: Account!
  auraLocker: AuraLocker!
  balance: BigInt!

  """
  AuraLocker.balances(account)
  """
  balanceLocked: BigInt!
  balanceNextUnlockIndex: Int!

  """
  Either self-delegated (in which case delegate => this, or another account); or not set
  """
  delegate: AuraLockerAccount
  delegateChangedTransactions(
    first: Int = 100
    orderBy: LockerDelegateChangedTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LockerDelegateChangedTransaction_filter
  ): [LockerDelegateChangedTransaction!]!

  """
  Timestamp at which `delegate` was updated
  """
  delegateUpdatedAt: Int

  """
  Accounts delegating to this account
  """
  delegators(
    first: Int = 100
    orderBy: AuraLockerAccount_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: AuraLockerAccount_filter
  ): [AuraLockerAccount!]!

  """
  {Account.id}
  """
  id: ID!
  kickRewardTransactions(
    first: Int = 100
    orderBy: LockerKickRewardTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LockerKickRewardTransaction_filter
  ): [LockerKickRewardTransaction!]!
  rewardPaidTransactions(
    first: Int = 100
    orderBy: LockerRewardPaidTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LockerRewardPaidTransaction_filter
  ): [LockerRewardPaidTransaction!]!
  stakedTransactions(
    first: Int = 100
    orderBy: LockerStakedTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LockerStakedTransaction_filter
  ): [LockerStakedTransaction!]!

  """
  AuraLocker.userData(account)
  """
  userData(
    first: Int = 100
    orderBy: AuraLockerUserData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: AuraLockerUserData_filter
  ): [AuraLockerUserData!]!

  """
  AuraLocker.userLocks(account)
  """
  userLocks(
    first: Int = 100
    orderBy: AuraLockerUserLock_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: AuraLockerUserLock_filter
  ): [AuraLockerUserLock!]!
  userLocksLength: Int!
  withdrawnTransactions(
    first: Int = 100
    orderBy: LockerWithdrawnTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LockerWithdrawnTransaction_filter
  ): [LockerWithdrawnTransaction!]!
}

input AuraLockerAccount_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: String
  account_: Account_filter
  account_contains: String
  account_contains_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_gt: String
  account_gte: String
  account_in: [String!]
  account_lt: String
  account_lte: String
  account_not: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_not_in: [String!]
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  auraLocker: String
  auraLocker_: AuraLocker_filter
  auraLocker_contains: String
  auraLocker_contains_nocase: String
  auraLocker_ends_with: String
  auraLocker_ends_with_nocase: String
  auraLocker_gt: String
  auraLocker_gte: String
  auraLocker_in: [String!]
  auraLocker_lt: String
  auraLocker_lte: String
  auraLocker_not: String
  auraLocker_not_contains: String
  auraLocker_not_contains_nocase: String
  auraLocker_not_ends_with: String
  auraLocker_not_ends_with_nocase: String
  auraLocker_not_in: [String!]
  auraLocker_not_starts_with: String
  auraLocker_not_starts_with_nocase: String
  auraLocker_starts_with: String
  auraLocker_starts_with_nocase: String
  balance: BigInt
  balanceLocked: BigInt
  balanceLocked_gt: BigInt
  balanceLocked_gte: BigInt
  balanceLocked_in: [BigInt!]
  balanceLocked_lt: BigInt
  balanceLocked_lte: BigInt
  balanceLocked_not: BigInt
  balanceLocked_not_in: [BigInt!]
  balanceNextUnlockIndex: Int
  balanceNextUnlockIndex_gt: Int
  balanceNextUnlockIndex_gte: Int
  balanceNextUnlockIndex_in: [Int!]
  balanceNextUnlockIndex_lt: Int
  balanceNextUnlockIndex_lte: Int
  balanceNextUnlockIndex_not: Int
  balanceNextUnlockIndex_not_in: [Int!]
  balance_gt: BigInt
  balance_gte: BigInt
  balance_in: [BigInt!]
  balance_lt: BigInt
  balance_lte: BigInt
  balance_not: BigInt
  balance_not_in: [BigInt!]
  delegate: String
  delegateChangedTransactions_: LockerDelegateChangedTransaction_filter
  delegateUpdatedAt: Int
  delegateUpdatedAt_gt: Int
  delegateUpdatedAt_gte: Int
  delegateUpdatedAt_in: [Int!]
  delegateUpdatedAt_lt: Int
  delegateUpdatedAt_lte: Int
  delegateUpdatedAt_not: Int
  delegateUpdatedAt_not_in: [Int!]
  delegate_: AuraLockerAccount_filter
  delegate_contains: String
  delegate_contains_nocase: String
  delegate_ends_with: String
  delegate_ends_with_nocase: String
  delegate_gt: String
  delegate_gte: String
  delegate_in: [String!]
  delegate_lt: String
  delegate_lte: String
  delegate_not: String
  delegate_not_contains: String
  delegate_not_contains_nocase: String
  delegate_not_ends_with: String
  delegate_not_ends_with_nocase: String
  delegate_not_in: [String!]
  delegate_not_starts_with: String
  delegate_not_starts_with_nocase: String
  delegate_starts_with: String
  delegate_starts_with_nocase: String
  delegators_: AuraLockerAccount_filter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  kickRewardTransactions_: LockerKickRewardTransaction_filter
  rewardPaidTransactions_: LockerRewardPaidTransaction_filter
  stakedTransactions_: LockerStakedTransaction_filter
  userData_: AuraLockerUserData_filter
  userLocksLength: Int
  userLocksLength_gt: Int
  userLocksLength_gte: Int
  userLocksLength_in: [Int!]
  userLocksLength_lt: Int
  userLocksLength_lte: Int
  userLocksLength_not: Int
  userLocksLength_not_in: [Int!]
  userLocks_: AuraLockerUserLock_filter
  withdrawnTransactions_: LockerWithdrawnTransaction_filter
}

enum AuraLockerAccount_orderBy {
  account
  auraLocker
  balance
  balanceLocked
  balanceNextUnlockIndex
  delegate
  delegateChangedTransactions
  delegateUpdatedAt
  delegators
  id
  kickRewardTransactions
  rewardPaidTransactions
  stakedTransactions
  userData
  userLocks
  userLocksLength
  withdrawnTransactions
}

type AuraLockerRewardData implements RewardData {
  auraLocker: AuraLocker!

  """
  {token.id}
  """
  id: ID!
  lastUpdateTime: Int!
  periodFinish: Int!
  rewardPerTokenStored: BigInt!
  rewardRate: BigInt!
  token: Token!
}

input AuraLockerRewardData_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  auraLocker: String
  auraLocker_: AuraLocker_filter
  auraLocker_contains: String
  auraLocker_contains_nocase: String
  auraLocker_ends_with: String
  auraLocker_ends_with_nocase: String
  auraLocker_gt: String
  auraLocker_gte: String
  auraLocker_in: [String!]
  auraLocker_lt: String
  auraLocker_lte: String
  auraLocker_not: String
  auraLocker_not_contains: String
  auraLocker_not_contains_nocase: String
  auraLocker_not_ends_with: String
  auraLocker_not_ends_with_nocase: String
  auraLocker_not_in: [String!]
  auraLocker_not_starts_with: String
  auraLocker_not_starts_with_nocase: String
  auraLocker_starts_with: String
  auraLocker_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lastUpdateTime: Int
  lastUpdateTime_gt: Int
  lastUpdateTime_gte: Int
  lastUpdateTime_in: [Int!]
  lastUpdateTime_lt: Int
  lastUpdateTime_lte: Int
  lastUpdateTime_not: Int
  lastUpdateTime_not_in: [Int!]
  periodFinish: Int
  periodFinish_gt: Int
  periodFinish_gte: Int
  periodFinish_in: [Int!]
  periodFinish_lt: Int
  periodFinish_lte: Int
  periodFinish_not: Int
  periodFinish_not_in: [Int!]
  rewardPerTokenStored: BigInt
  rewardPerTokenStored_gt: BigInt
  rewardPerTokenStored_gte: BigInt
  rewardPerTokenStored_in: [BigInt!]
  rewardPerTokenStored_lt: BigInt
  rewardPerTokenStored_lte: BigInt
  rewardPerTokenStored_not: BigInt
  rewardPerTokenStored_not_in: [BigInt!]
  rewardRate: BigInt
  rewardRate_gt: BigInt
  rewardRate_gte: BigInt
  rewardRate_in: [BigInt!]
  rewardRate_lt: BigInt
  rewardRate_lte: BigInt
  rewardRate_not: BigInt
  rewardRate_not_in: [BigInt!]
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
}

enum AuraLockerRewardData_orderBy {
  auraLocker
  id
  lastUpdateTime
  periodFinish
  rewardPerTokenStored
  rewardRate
  token
}

type AuraLockerUserData {
  auraLockerAccount: AuraLockerAccount!

  """
  {AuraLockerAccount.id}.{Token.id}
  """
  id: ID!
  rewardPerTokenPaid: BigInt!
  rewards: BigInt!
  token: Token!
}

input AuraLockerUserData_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  auraLockerAccount: String
  auraLockerAccount_: AuraLockerAccount_filter
  auraLockerAccount_contains: String
  auraLockerAccount_contains_nocase: String
  auraLockerAccount_ends_with: String
  auraLockerAccount_ends_with_nocase: String
  auraLockerAccount_gt: String
  auraLockerAccount_gte: String
  auraLockerAccount_in: [String!]
  auraLockerAccount_lt: String
  auraLockerAccount_lte: String
  auraLockerAccount_not: String
  auraLockerAccount_not_contains: String
  auraLockerAccount_not_contains_nocase: String
  auraLockerAccount_not_ends_with: String
  auraLockerAccount_not_ends_with_nocase: String
  auraLockerAccount_not_in: [String!]
  auraLockerAccount_not_starts_with: String
  auraLockerAccount_not_starts_with_nocase: String
  auraLockerAccount_starts_with: String
  auraLockerAccount_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  rewardPerTokenPaid: BigInt
  rewardPerTokenPaid_gt: BigInt
  rewardPerTokenPaid_gte: BigInt
  rewardPerTokenPaid_in: [BigInt!]
  rewardPerTokenPaid_lt: BigInt
  rewardPerTokenPaid_lte: BigInt
  rewardPerTokenPaid_not: BigInt
  rewardPerTokenPaid_not_in: [BigInt!]
  rewards: BigInt
  rewards_gt: BigInt
  rewards_gte: BigInt
  rewards_in: [BigInt!]
  rewards_lt: BigInt
  rewards_lte: BigInt
  rewards_not: BigInt
  rewards_not_in: [BigInt!]
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
}

enum AuraLockerUserData_orderBy {
  auraLockerAccount
  id
  rewardPerTokenPaid
  rewards
  token
}

type AuraLockerUserLock {
  amount: BigInt!
  auraLockerAccount: AuraLockerAccount!

  """
  {AuraLockerAccount.id}.{index}
  """
  id: ID!
  unlockTime: Int!
}

input AuraLockerUserLock_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  auraLockerAccount: String
  auraLockerAccount_: AuraLockerAccount_filter
  auraLockerAccount_contains: String
  auraLockerAccount_contains_nocase: String
  auraLockerAccount_ends_with: String
  auraLockerAccount_ends_with_nocase: String
  auraLockerAccount_gt: String
  auraLockerAccount_gte: String
  auraLockerAccount_in: [String!]
  auraLockerAccount_lt: String
  auraLockerAccount_lte: String
  auraLockerAccount_not: String
  auraLockerAccount_not_contains: String
  auraLockerAccount_not_contains_nocase: String
  auraLockerAccount_not_ends_with: String
  auraLockerAccount_not_ends_with_nocase: String
  auraLockerAccount_not_in: [String!]
  auraLockerAccount_not_starts_with: String
  auraLockerAccount_not_starts_with_nocase: String
  auraLockerAccount_starts_with: String
  auraLockerAccount_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  unlockTime: Int
  unlockTime_gt: Int
  unlockTime_gte: Int
  unlockTime_in: [Int!]
  unlockTime_lt: Int
  unlockTime_lte: Int
  unlockTime_not: Int
  unlockTime_not_in: [Int!]
}

enum AuraLockerUserLock_orderBy {
  amount
  auraLockerAccount
  id
  unlockTime
}

input AuraLocker_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  accounts_: AuraLockerAccount_filter
  address: Bytes
  address_contains: Bytes
  address_in: [Bytes!]
  address_not: Bytes
  address_not_contains: Bytes
  address_not_in: [Bytes!]
  delegateChangedTransactions_: LockerDelegateChangedTransaction_filter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isShutdown: Boolean
  isShutdown_in: [Boolean!]
  isShutdown_not: Boolean
  isShutdown_not_in: [Boolean!]
  kickRewardTransactions_: LockerKickRewardTransaction_filter
  lockedSupply: BigInt
  lockedSupply_gt: BigInt
  lockedSupply_gte: BigInt
  lockedSupply_in: [BigInt!]
  lockedSupply_lt: BigInt
  lockedSupply_lte: BigInt
  lockedSupply_not: BigInt
  lockedSupply_not_in: [BigInt!]
  rewardData_: AuraLockerRewardData_filter
  rewardPaidTransactions_: LockerRewardPaidTransaction_filter
  stakedTransactions_: LockerStakedTransaction_filter
  totalSupply: BigInt
  totalSupply_gt: BigInt
  totalSupply_gte: BigInt
  totalSupply_in: [BigInt!]
  totalSupply_lt: BigInt
  totalSupply_lte: BigInt
  totalSupply_not: BigInt
  totalSupply_not_in: [BigInt!]
  withdrawnTransactions_: LockerWithdrawnTransaction_filter
}

enum AuraLocker_orderBy {
  accounts
  address
  delegateChangedTransactions
  id
  isShutdown
  kickRewardTransactions
  lockedSupply
  rewardData
  rewardPaidTransactions
  stakedTransactions
  totalSupply
  withdrawnTransactions
}

type Balancer {
  id: ID!
  poolCount: Int!
  pools(
    first: Int = 100
    orderBy: Pool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Pool_filter
  ): [Pool!]
  totalLiquidity: BigDecimal!
  totalSwapCount: BigInt!
  totalSwapFee: BigDecimal!
  totalSwapVolume: BigDecimal!
}

type BalancerSnapshot {
  id: ID!
  poolCount: Int!
  timestamp: Int!
  totalLiquidity: BigDecimal!
  totalSwapCount: BigInt!
  totalSwapFee: BigDecimal!
  totalSwapVolume: BigDecimal!
  vault: Balancer!
}

input BalancerSnapshot_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [BalancerSnapshot_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [BalancerSnapshot_filter]
  poolCount: Int
  poolCount_gt: Int
  poolCount_gte: Int
  poolCount_in: [Int!]
  poolCount_lt: Int
  poolCount_lte: Int
  poolCount_not: Int
  poolCount_not_in: [Int!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  totalLiquidity: BigDecimal
  totalLiquidity_gt: BigDecimal
  totalLiquidity_gte: BigDecimal
  totalLiquidity_in: [BigDecimal!]
  totalLiquidity_lt: BigDecimal
  totalLiquidity_lte: BigDecimal
  totalLiquidity_not: BigDecimal
  totalLiquidity_not_in: [BigDecimal!]
  totalSwapCount: BigInt
  totalSwapCount_gt: BigInt
  totalSwapCount_gte: BigInt
  totalSwapCount_in: [BigInt!]
  totalSwapCount_lt: BigInt
  totalSwapCount_lte: BigInt
  totalSwapCount_not: BigInt
  totalSwapCount_not_in: [BigInt!]
  totalSwapFee: BigDecimal
  totalSwapFee_gt: BigDecimal
  totalSwapFee_gte: BigDecimal
  totalSwapFee_in: [BigDecimal!]
  totalSwapFee_lt: BigDecimal
  totalSwapFee_lte: BigDecimal
  totalSwapFee_not: BigDecimal
  totalSwapFee_not_in: [BigDecimal!]
  totalSwapVolume: BigDecimal
  totalSwapVolume_gt: BigDecimal
  totalSwapVolume_gte: BigDecimal
  totalSwapVolume_in: [BigDecimal!]
  totalSwapVolume_lt: BigDecimal
  totalSwapVolume_lte: BigDecimal
  totalSwapVolume_not: BigDecimal
  totalSwapVolume_not_in: [BigDecimal!]
  vault: String
  vault_: Balancer_filter
  vault_contains: String
  vault_contains_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_gt: String
  vault_gte: String
  vault_in: [String!]
  vault_lt: String
  vault_lte: String
  vault_not: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_not_in: [String!]
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
}

enum BalancerSnapshot_orderBy {
  id
  poolCount
  timestamp
  totalLiquidity
  totalSwapCount
  totalSwapFee
  totalSwapVolume
  vault
  vault__id
  vault__poolCount
  vault__totalLiquidity
  vault__totalSwapCount
  vault__totalSwapFee
  vault__totalSwapVolume
}

input Balancer_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Balancer_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [Balancer_filter]
  poolCount: Int
  poolCount_gt: Int
  poolCount_gte: Int
  poolCount_in: [Int!]
  poolCount_lt: Int
  poolCount_lte: Int
  poolCount_not: Int
  poolCount_not_in: [Int!]
  pools_: Pool_filter
  totalLiquidity: BigDecimal
  totalLiquidity_gt: BigDecimal
  totalLiquidity_gte: BigDecimal
  totalLiquidity_in: [BigDecimal!]
  totalLiquidity_lt: BigDecimal
  totalLiquidity_lte: BigDecimal
  totalLiquidity_not: BigDecimal
  totalLiquidity_not_in: [BigDecimal!]
  totalSwapCount: BigInt
  totalSwapCount_gt: BigInt
  totalSwapCount_gte: BigInt
  totalSwapCount_in: [BigInt!]
  totalSwapCount_lt: BigInt
  totalSwapCount_lte: BigInt
  totalSwapCount_not: BigInt
  totalSwapCount_not_in: [BigInt!]
  totalSwapFee: BigDecimal
  totalSwapFee_gt: BigDecimal
  totalSwapFee_gte: BigDecimal
  totalSwapFee_in: [BigDecimal!]
  totalSwapFee_lt: BigDecimal
  totalSwapFee_lte: BigDecimal
  totalSwapFee_not: BigDecimal
  totalSwapFee_not_in: [BigDecimal!]
  totalSwapVolume: BigDecimal
  totalSwapVolume_gt: BigDecimal
  totalSwapVolume_gte: BigDecimal
  totalSwapVolume_in: [BigDecimal!]
  totalSwapVolume_lt: BigDecimal
  totalSwapVolume_lte: BigDecimal
  totalSwapVolume_not: BigDecimal
  totalSwapVolume_not_in: [BigDecimal!]
}

enum Balancer_orderBy {
  id
  poolCount
  pools
  totalLiquidity
  totalSwapCount
  totalSwapFee
  totalSwapVolume
}

scalar BigDecimal

scalar BigInt

type Block {
  author: String
  difficulty: BigInt
  gasLimit: BigInt
  gasUsed: BigInt
  id: ID!
  number: BigInt!
  parentHash: String
  receiptsRoot: String
  size: BigInt
  stateRoot: String
  timestamp: BigInt!
  totalDifficulty: BigInt
  transactionsRoot: String
  unclesHash: String
}

input BlockChangedFilter {
  number_gte: Int!
}

input Block_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Block_filter]
  author: String
  author_contains: String
  author_contains_nocase: String
  author_ends_with: String
  author_ends_with_nocase: String
  author_gt: String
  author_gte: String
  author_in: [String!]
  author_lt: String
  author_lte: String
  author_not: String
  author_not_contains: String
  author_not_contains_nocase: String
  author_not_ends_with: String
  author_not_ends_with_nocase: String
  author_not_in: [String!]
  author_not_starts_with: String
  author_not_starts_with_nocase: String
  author_starts_with: String
  author_starts_with_nocase: String
  difficulty: BigInt
  difficulty_gt: BigInt
  difficulty_gte: BigInt
  difficulty_in: [BigInt!]
  difficulty_lt: BigInt
  difficulty_lte: BigInt
  difficulty_not: BigInt
  difficulty_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_gt: BigInt
  gasLimit_gte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_lt: BigInt
  gasLimit_lte: BigInt
  gasLimit_not: BigInt
  gasLimit_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_gt: BigInt
  gasUsed_gte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_lt: BigInt
  gasUsed_lte: BigInt
  gasUsed_not: BigInt
  gasUsed_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  number: BigInt
  number_gt: BigInt
  number_gte: BigInt
  number_in: [BigInt!]
  number_lt: BigInt
  number_lte: BigInt
  number_not: BigInt
  number_not_in: [BigInt!]
  or: [Block_filter]
  parentHash: String
  parentHash_contains: String
  parentHash_contains_nocase: String
  parentHash_ends_with: String
  parentHash_ends_with_nocase: String
  parentHash_gt: String
  parentHash_gte: String
  parentHash_in: [String!]
  parentHash_lt: String
  parentHash_lte: String
  parentHash_not: String
  parentHash_not_contains: String
  parentHash_not_contains_nocase: String
  parentHash_not_ends_with: String
  parentHash_not_ends_with_nocase: String
  parentHash_not_in: [String!]
  parentHash_not_starts_with: String
  parentHash_not_starts_with_nocase: String
  parentHash_starts_with: String
  parentHash_starts_with_nocase: String
  receiptsRoot: String
  receiptsRoot_contains: String
  receiptsRoot_contains_nocase: String
  receiptsRoot_ends_with: String
  receiptsRoot_ends_with_nocase: String
  receiptsRoot_gt: String
  receiptsRoot_gte: String
  receiptsRoot_in: [String!]
  receiptsRoot_lt: String
  receiptsRoot_lte: String
  receiptsRoot_not: String
  receiptsRoot_not_contains: String
  receiptsRoot_not_contains_nocase: String
  receiptsRoot_not_ends_with: String
  receiptsRoot_not_ends_with_nocase: String
  receiptsRoot_not_in: [String!]
  receiptsRoot_not_starts_with: String
  receiptsRoot_not_starts_with_nocase: String
  receiptsRoot_starts_with: String
  receiptsRoot_starts_with_nocase: String
  size: BigInt
  size_gt: BigInt
  size_gte: BigInt
  size_in: [BigInt!]
  size_lt: BigInt
  size_lte: BigInt
  size_not: BigInt
  size_not_in: [BigInt!]
  stateRoot: String
  stateRoot_contains: String
  stateRoot_contains_nocase: String
  stateRoot_ends_with: String
  stateRoot_ends_with_nocase: String
  stateRoot_gt: String
  stateRoot_gte: String
  stateRoot_in: [String!]
  stateRoot_lt: String
  stateRoot_lte: String
  stateRoot_not: String
  stateRoot_not_contains: String
  stateRoot_not_contains_nocase: String
  stateRoot_not_ends_with: String
  stateRoot_not_ends_with_nocase: String
  stateRoot_not_in: [String!]
  stateRoot_not_starts_with: String
  stateRoot_not_starts_with_nocase: String
  stateRoot_starts_with: String
  stateRoot_starts_with_nocase: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  totalDifficulty: BigInt
  totalDifficulty_gt: BigInt
  totalDifficulty_gte: BigInt
  totalDifficulty_in: [BigInt!]
  totalDifficulty_lt: BigInt
  totalDifficulty_lte: BigInt
  totalDifficulty_not: BigInt
  totalDifficulty_not_in: [BigInt!]
  transactionsRoot: String
  transactionsRoot_contains: String
  transactionsRoot_contains_nocase: String
  transactionsRoot_ends_with: String
  transactionsRoot_ends_with_nocase: String
  transactionsRoot_gt: String
  transactionsRoot_gte: String
  transactionsRoot_in: [String!]
  transactionsRoot_lt: String
  transactionsRoot_lte: String
  transactionsRoot_not: String
  transactionsRoot_not_contains: String
  transactionsRoot_not_contains_nocase: String
  transactionsRoot_not_ends_with: String
  transactionsRoot_not_ends_with_nocase: String
  transactionsRoot_not_in: [String!]
  transactionsRoot_not_starts_with: String
  transactionsRoot_not_starts_with_nocase: String
  transactionsRoot_starts_with: String
  transactionsRoot_starts_with_nocase: String
  unclesHash: String
  unclesHash_contains: String
  unclesHash_contains_nocase: String
  unclesHash_ends_with: String
  unclesHash_ends_with_nocase: String
  unclesHash_gt: String
  unclesHash_gte: String
  unclesHash_in: [String!]
  unclesHash_lt: String
  unclesHash_lte: String
  unclesHash_not: String
  unclesHash_not_contains: String
  unclesHash_not_contains_nocase: String
  unclesHash_not_ends_with: String
  unclesHash_not_ends_with_nocase: String
  unclesHash_not_in: [String!]
  unclesHash_not_starts_with: String
  unclesHash_not_starts_with_nocase: String
  unclesHash_starts_with: String
  unclesHash_starts_with_nocase: String
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

enum Block_orderBy {
  author
  difficulty
  gasLimit
  gasUsed
  id
  number
  parentHash
  receiptsRoot
  size
  stateRoot
  timestamp
  totalDifficulty
  transactionsRoot
  unclesHash
}

scalar Bytes

type FactoryPoolData {
  """
  Timestamp at which the pool was added
  """
  addedAt: Int
  balancerPoolId: Bytes
  gauge: Bytes!

  """
  {pool.id}
  """
  id: ID!
  isShutdown: Boolean!
  pool: Pool!
  stash: Bytes!
}

input FactoryPoolData_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  addedAt: Int
  addedAt_gt: Int
  addedAt_gte: Int
  addedAt_in: [Int!]
  addedAt_lt: Int
  addedAt_lte: Int
  addedAt_not: Int
  addedAt_not_in: [Int!]
  balancerPoolId: Bytes
  balancerPoolId_contains: Bytes
  balancerPoolId_in: [Bytes!]
  balancerPoolId_not: Bytes
  balancerPoolId_not_contains: Bytes
  balancerPoolId_not_in: [Bytes!]
  gauge: Bytes
  gauge_contains: Bytes
  gauge_in: [Bytes!]
  gauge_not: Bytes
  gauge_not_contains: Bytes
  gauge_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isShutdown: Boolean
  isShutdown_in: [Boolean!]
  isShutdown_not: Boolean
  isShutdown_not_in: [Boolean!]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  stash: Bytes
  stash_contains: Bytes
  stash_in: [Bytes!]
  stash_not: Bytes
  stash_not_contains: Bytes
  stash_not_in: [Bytes!]
}

enum FactoryPoolData_orderBy {
  addedAt
  balancerPoolId
  gauge
  id
  isShutdown
  pool
  stash
}

type Gauge {
  """
  gauge.balanceOf(auraProxy)
  """
  balance: BigInt!

  """
  Address
  """
  id: ID!
  pool: Pool
  totalSupply: BigInt!
  workingSupply: BigInt!
}

input Gauge_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  balance: BigInt
  balance_gt: BigInt
  balance_gte: BigInt
  balance_in: [BigInt!]
  balance_lt: BigInt
  balance_lte: BigInt
  balance_not: BigInt
  balance_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  totalSupply: BigInt
  totalSupply_gt: BigInt
  totalSupply_gte: BigInt
  totalSupply_in: [BigInt!]
  totalSupply_lt: BigInt
  totalSupply_lte: BigInt
  totalSupply_not: BigInt
  totalSupply_not_in: [BigInt!]
  workingSupply: BigInt
  workingSupply_gt: BigInt
  workingSupply_gte: BigInt
  workingSupply_in: [BigInt!]
  workingSupply_lt: BigInt
  workingSupply_lte: BigInt
  workingSupply_not: BigInt
  workingSupply_not_in: [BigInt!]
}

enum Gauge_orderBy {
  balance
  id
  pool
  totalSupply
  workingSupply
}

type Global {
  aura: Bytes!
  auraBalTotalSupply: BigInt!
  auraMaxSupply: BigInt!
  auraMinter: Bytes!
  auraMinterMinted: BigInt!
  auraReductionPerCliff: BigInt!
  auraTotalCliffs: BigInt!
  auraTotalSupply: BigInt!
  booster: Bytes!
  earmarkIncentive: BigInt!

  """
  Singleton: "global"
  """
  id: ID!
  lockIncentive: BigInt!
  platformFee: BigInt!
  stakerIncentive: BigInt!
  voteDelegate: Bytes!
}

input Global_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  aura: Bytes
  auraBalTotalSupply: BigInt
  auraBalTotalSupply_gt: BigInt
  auraBalTotalSupply_gte: BigInt
  auraBalTotalSupply_in: [BigInt!]
  auraBalTotalSupply_lt: BigInt
  auraBalTotalSupply_lte: BigInt
  auraBalTotalSupply_not: BigInt
  auraBalTotalSupply_not_in: [BigInt!]
  auraMaxSupply: BigInt
  auraMaxSupply_gt: BigInt
  auraMaxSupply_gte: BigInt
  auraMaxSupply_in: [BigInt!]
  auraMaxSupply_lt: BigInt
  auraMaxSupply_lte: BigInt
  auraMaxSupply_not: BigInt
  auraMaxSupply_not_in: [BigInt!]
  auraMinter: Bytes
  auraMinterMinted: BigInt
  auraMinterMinted_gt: BigInt
  auraMinterMinted_gte: BigInt
  auraMinterMinted_in: [BigInt!]
  auraMinterMinted_lt: BigInt
  auraMinterMinted_lte: BigInt
  auraMinterMinted_not: BigInt
  auraMinterMinted_not_in: [BigInt!]
  auraMinter_contains: Bytes
  auraMinter_in: [Bytes!]
  auraMinter_not: Bytes
  auraMinter_not_contains: Bytes
  auraMinter_not_in: [Bytes!]
  auraReductionPerCliff: BigInt
  auraReductionPerCliff_gt: BigInt
  auraReductionPerCliff_gte: BigInt
  auraReductionPerCliff_in: [BigInt!]
  auraReductionPerCliff_lt: BigInt
  auraReductionPerCliff_lte: BigInt
  auraReductionPerCliff_not: BigInt
  auraReductionPerCliff_not_in: [BigInt!]
  auraTotalCliffs: BigInt
  auraTotalCliffs_gt: BigInt
  auraTotalCliffs_gte: BigInt
  auraTotalCliffs_in: [BigInt!]
  auraTotalCliffs_lt: BigInt
  auraTotalCliffs_lte: BigInt
  auraTotalCliffs_not: BigInt
  auraTotalCliffs_not_in: [BigInt!]
  auraTotalSupply: BigInt
  auraTotalSupply_gt: BigInt
  auraTotalSupply_gte: BigInt
  auraTotalSupply_in: [BigInt!]
  auraTotalSupply_lt: BigInt
  auraTotalSupply_lte: BigInt
  auraTotalSupply_not: BigInt
  auraTotalSupply_not_in: [BigInt!]
  aura_contains: Bytes
  aura_in: [Bytes!]
  aura_not: Bytes
  aura_not_contains: Bytes
  aura_not_in: [Bytes!]
  booster: Bytes
  booster_contains: Bytes
  booster_in: [Bytes!]
  booster_not: Bytes
  booster_not_contains: Bytes
  booster_not_in: [Bytes!]
  earmarkIncentive: BigInt
  earmarkIncentive_gt: BigInt
  earmarkIncentive_gte: BigInt
  earmarkIncentive_in: [BigInt!]
  earmarkIncentive_lt: BigInt
  earmarkIncentive_lte: BigInt
  earmarkIncentive_not: BigInt
  earmarkIncentive_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lockIncentive: BigInt
  lockIncentive_gt: BigInt
  lockIncentive_gte: BigInt
  lockIncentive_in: [BigInt!]
  lockIncentive_lt: BigInt
  lockIncentive_lte: BigInt
  lockIncentive_not: BigInt
  lockIncentive_not_in: [BigInt!]
  platformFee: BigInt
  platformFee_gt: BigInt
  platformFee_gte: BigInt
  platformFee_in: [BigInt!]
  platformFee_lt: BigInt
  platformFee_lte: BigInt
  platformFee_not: BigInt
  platformFee_not_in: [BigInt!]
  stakerIncentive: BigInt
  stakerIncentive_gt: BigInt
  stakerIncentive_gte: BigInt
  stakerIncentive_in: [BigInt!]
  stakerIncentive_lt: BigInt
  stakerIncentive_lte: BigInt
  stakerIncentive_not: BigInt
  stakerIncentive_not_in: [BigInt!]
  voteDelegate: Bytes
  voteDelegate_contains: Bytes
  voteDelegate_in: [Bytes!]
  voteDelegate_not: Bytes
  voteDelegate_not_contains: Bytes
  voteDelegate_not_in: [Bytes!]
}

enum Global_orderBy {
  aura
  auraBalTotalSupply
  auraMaxSupply
  auraMinter
  auraMinterMinted
  auraReductionPerCliff
  auraTotalCliffs
  auraTotalSupply
  booster
  earmarkIncentive
  id
  lockIncentive
  platformFee
  stakerIncentive
  voteDelegate
}

type GradualWeightUpdate {
  endTimestamp: BigInt!
  endWeights: [BigInt!]!
  id: ID!
  poolId: Pool!
  scheduledTimestamp: Int!
  startTimestamp: BigInt!
  startWeights: [BigInt!]!
}

input GradualWeightUpdate_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [GradualWeightUpdate_filter]
  endTimestamp: BigInt
  endTimestamp_gt: BigInt
  endTimestamp_gte: BigInt
  endTimestamp_in: [BigInt!]
  endTimestamp_lt: BigInt
  endTimestamp_lte: BigInt
  endTimestamp_not: BigInt
  endTimestamp_not_in: [BigInt!]
  endWeights: [BigInt!]
  endWeights_contains: [BigInt!]
  endWeights_contains_nocase: [BigInt!]
  endWeights_not: [BigInt!]
  endWeights_not_contains: [BigInt!]
  endWeights_not_contains_nocase: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [GradualWeightUpdate_filter]
  poolId: String
  poolId_: Pool_filter
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_gt: String
  poolId_gte: String
  poolId_in: [String!]
  poolId_lt: String
  poolId_lte: String
  poolId_not: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  poolId_not_in: [String!]
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  scheduledTimestamp: Int
  scheduledTimestamp_gt: Int
  scheduledTimestamp_gte: Int
  scheduledTimestamp_in: [Int!]
  scheduledTimestamp_lt: Int
  scheduledTimestamp_lte: Int
  scheduledTimestamp_not: Int
  scheduledTimestamp_not_in: [Int!]
  startTimestamp: BigInt
  startTimestamp_gt: BigInt
  startTimestamp_gte: BigInt
  startTimestamp_in: [BigInt!]
  startTimestamp_lt: BigInt
  startTimestamp_lte: BigInt
  startTimestamp_not: BigInt
  startTimestamp_not_in: [BigInt!]
  startWeights: [BigInt!]
  startWeights_contains: [BigInt!]
  startWeights_contains_nocase: [BigInt!]
  startWeights_not: [BigInt!]
  startWeights_not_contains: [BigInt!]
  startWeights_not_contains_nocase: [BigInt!]
}

enum GradualWeightUpdate_orderBy {
  endTimestamp
  endWeights
  id
  poolId
  poolId__address
  poolId__alpha
  poolId__amp
  poolId__baseToken
  poolId__beta
  poolId__c
  poolId__createTime
  poolId__dSq
  poolId__delta
  poolId__epsilon
  poolId__expiryTime
  poolId__factory
  poolId__holdersCount
  poolId__id
  poolId__isInRecoveryMode
  poolId__isPaused
  poolId__lambda
  poolId__lastPostJoinExitInvariant
  poolId__lowerTarget
  poolId__mainIndex
  poolId__managementFee
  poolId__name
  poolId__oracleEnabled
  poolId__owner
  poolId__poolType
  poolId__poolTypeVersion
  poolId__principalToken
  poolId__protocolAumFeeCache
  poolId__protocolId
  poolId__protocolSwapFeeCache
  poolId__protocolYieldFeeCache
  poolId__root3Alpha
  poolId__s
  poolId__sqrtAlpha
  poolId__sqrtBeta
  poolId__strategyType
  poolId__swapEnabled
  poolId__swapFee
  poolId__swapsCount
  poolId__symbol
  poolId__tauAlphaX
  poolId__tauAlphaY
  poolId__tauBetaX
  poolId__tauBetaY
  poolId__totalLiquidity
  poolId__totalShares
  poolId__totalSwapFee
  poolId__totalSwapVolume
  poolId__totalWeight
  poolId__tx
  poolId__u
  poolId__unitSeconds
  poolId__upperTarget
  poolId__v
  poolId__w
  poolId__wrappedIndex
  poolId__z
  scheduledTimestamp
  startTimestamp
  startWeights
}

enum InvestType {
  Exit
  Join
}

type JoinExit {
  amounts: [BigDecimal!]!
  id: ID!
  pool: Pool!
  sender: Bytes!
  timestamp: Int!
  tx: Bytes!
  type: InvestType!
  user: User!
  valueUSD: BigDecimal
}

input JoinExit_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amounts: [BigDecimal!]
  amounts_contains: [BigDecimal!]
  amounts_contains_nocase: [BigDecimal!]
  amounts_not: [BigDecimal!]
  amounts_not_contains: [BigDecimal!]
  amounts_not_contains_nocase: [BigDecimal!]
  and: [JoinExit_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [JoinExit_filter]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  sender: Bytes
  sender_contains: Bytes
  sender_gt: Bytes
  sender_gte: Bytes
  sender_in: [Bytes!]
  sender_lt: Bytes
  sender_lte: Bytes
  sender_not: Bytes
  sender_not_contains: Bytes
  sender_not_in: [Bytes!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  tx: Bytes
  tx_contains: Bytes
  tx_gt: Bytes
  tx_gte: Bytes
  tx_in: [Bytes!]
  tx_lt: Bytes
  tx_lte: Bytes
  tx_not: Bytes
  tx_not_contains: Bytes
  tx_not_in: [Bytes!]
  type: InvestType
  type_in: [InvestType!]
  type_not: InvestType
  type_not_in: [InvestType!]
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
  valueUSD: BigDecimal
  valueUSD_gt: BigDecimal
  valueUSD_gte: BigDecimal
  valueUSD_in: [BigDecimal!]
  valueUSD_lt: BigDecimal
  valueUSD_lte: BigDecimal
  valueUSD_not: BigDecimal
  valueUSD_not_in: [BigDecimal!]
}

enum JoinExit_orderBy {
  amounts
  id
  pool
  pool__address
  pool__alpha
  pool__amp
  pool__baseToken
  pool__beta
  pool__c
  pool__createTime
  pool__dSq
  pool__delta
  pool__epsilon
  pool__expiryTime
  pool__factory
  pool__holdersCount
  pool__id
  pool__isInRecoveryMode
  pool__isPaused
  pool__lambda
  pool__lastPostJoinExitInvariant
  pool__lowerTarget
  pool__mainIndex
  pool__managementFee
  pool__name
  pool__oracleEnabled
  pool__owner
  pool__poolType
  pool__poolTypeVersion
  pool__principalToken
  pool__protocolAumFeeCache
  pool__protocolId
  pool__protocolSwapFeeCache
  pool__protocolYieldFeeCache
  pool__root3Alpha
  pool__s
  pool__sqrtAlpha
  pool__sqrtBeta
  pool__strategyType
  pool__swapEnabled
  pool__swapFee
  pool__swapsCount
  pool__symbol
  pool__tauAlphaX
  pool__tauAlphaY
  pool__tauBetaX
  pool__tauBetaY
  pool__totalLiquidity
  pool__totalShares
  pool__totalSwapFee
  pool__totalSwapVolume
  pool__totalWeight
  pool__tx
  pool__u
  pool__unitSeconds
  pool__upperTarget
  pool__v
  pool__w
  pool__wrappedIndex
  pool__z
  sender
  timestamp
  tx
  type
  user
  user__id
  valueUSD
}

type LatestPrice {
  asset: Bytes!
  block: BigInt!
  id: ID!
  poolId: Pool!
  price: BigDecimal!
  pricingAsset: Bytes!
}

input LatestPrice_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [LatestPrice_filter]
  asset: Bytes
  asset_contains: Bytes
  asset_gt: Bytes
  asset_gte: Bytes
  asset_in: [Bytes!]
  asset_lt: Bytes
  asset_lte: Bytes
  asset_not: Bytes
  asset_not_contains: Bytes
  asset_not_in: [Bytes!]
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [LatestPrice_filter]
  poolId: String
  poolId_: Pool_filter
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_gt: String
  poolId_gte: String
  poolId_in: [String!]
  poolId_lt: String
  poolId_lte: String
  poolId_not: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  poolId_not_in: [String!]
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  price: BigDecimal
  price_gt: BigDecimal
  price_gte: BigDecimal
  price_in: [BigDecimal!]
  price_lt: BigDecimal
  price_lte: BigDecimal
  price_not: BigDecimal
  price_not_in: [BigDecimal!]
  pricingAsset: Bytes
  pricingAsset_contains: Bytes
  pricingAsset_gt: Bytes
  pricingAsset_gte: Bytes
  pricingAsset_in: [Bytes!]
  pricingAsset_lt: Bytes
  pricingAsset_lte: Bytes
  pricingAsset_not: Bytes
  pricingAsset_not_contains: Bytes
  pricingAsset_not_in: [Bytes!]
}

enum LatestPrice_orderBy {
  asset
  block
  id
  poolId
  poolId__address
  poolId__alpha
  poolId__amp
  poolId__baseToken
  poolId__beta
  poolId__c
  poolId__createTime
  poolId__dSq
  poolId__delta
  poolId__epsilon
  poolId__expiryTime
  poolId__factory
  poolId__holdersCount
  poolId__id
  poolId__isInRecoveryMode
  poolId__isPaused
  poolId__lambda
  poolId__lastPostJoinExitInvariant
  poolId__lowerTarget
  poolId__mainIndex
  poolId__managementFee
  poolId__name
  poolId__oracleEnabled
  poolId__owner
  poolId__poolType
  poolId__poolTypeVersion
  poolId__principalToken
  poolId__protocolAumFeeCache
  poolId__protocolId
  poolId__protocolSwapFeeCache
  poolId__protocolYieldFeeCache
  poolId__root3Alpha
  poolId__s
  poolId__sqrtAlpha
  poolId__sqrtBeta
  poolId__strategyType
  poolId__swapEnabled
  poolId__swapFee
  poolId__swapsCount
  poolId__symbol
  poolId__tauAlphaX
  poolId__tauAlphaY
  poolId__tauBetaX
  poolId__tauBetaY
  poolId__totalLiquidity
  poolId__totalShares
  poolId__totalSwapFee
  poolId__totalSwapVolume
  poolId__totalWeight
  poolId__tx
  poolId__u
  poolId__unitSeconds
  poolId__upperTarget
  poolId__v
  poolId__w
  poolId__wrappedIndex
  poolId__z
  price
  pricingAsset
}

type LockerDelegateChangedTransaction implements LockerTransaction {
  auraLocker: AuraLocker!
  auraLockerAccount: AuraLockerAccount!
  fromDelegate: Bytes!
  hash: Bytes!
  id: ID!
  timestamp: Int!
  toDelegate: Bytes!
}

input LockerDelegateChangedTransaction_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  auraLocker: String
  auraLockerAccount: String
  auraLockerAccount_: AuraLockerAccount_filter
  auraLockerAccount_contains: String
  auraLockerAccount_contains_nocase: String
  auraLockerAccount_ends_with: String
  auraLockerAccount_ends_with_nocase: String
  auraLockerAccount_gt: String
  auraLockerAccount_gte: String
  auraLockerAccount_in: [String!]
  auraLockerAccount_lt: String
  auraLockerAccount_lte: String
  auraLockerAccount_not: String
  auraLockerAccount_not_contains: String
  auraLockerAccount_not_contains_nocase: String
  auraLockerAccount_not_ends_with: String
  auraLockerAccount_not_ends_with_nocase: String
  auraLockerAccount_not_in: [String!]
  auraLockerAccount_not_starts_with: String
  auraLockerAccount_not_starts_with_nocase: String
  auraLockerAccount_starts_with: String
  auraLockerAccount_starts_with_nocase: String
  auraLocker_: AuraLocker_filter
  auraLocker_contains: String
  auraLocker_contains_nocase: String
  auraLocker_ends_with: String
  auraLocker_ends_with_nocase: String
  auraLocker_gt: String
  auraLocker_gte: String
  auraLocker_in: [String!]
  auraLocker_lt: String
  auraLocker_lte: String
  auraLocker_not: String
  auraLocker_not_contains: String
  auraLocker_not_contains_nocase: String
  auraLocker_not_ends_with: String
  auraLocker_not_ends_with_nocase: String
  auraLocker_not_in: [String!]
  auraLocker_not_starts_with: String
  auraLocker_not_starts_with_nocase: String
  auraLocker_starts_with: String
  auraLocker_starts_with_nocase: String
  fromDelegate: Bytes
  fromDelegate_contains: Bytes
  fromDelegate_in: [Bytes!]
  fromDelegate_not: Bytes
  fromDelegate_not_contains: Bytes
  fromDelegate_not_in: [Bytes!]
  hash: Bytes
  hash_contains: Bytes
  hash_in: [Bytes!]
  hash_not: Bytes
  hash_not_contains: Bytes
  hash_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  toDelegate: Bytes
  toDelegate_contains: Bytes
  toDelegate_in: [Bytes!]
  toDelegate_not: Bytes
  toDelegate_not_contains: Bytes
  toDelegate_not_in: [Bytes!]
}

enum LockerDelegateChangedTransaction_orderBy {
  auraLocker
  auraLockerAccount
  fromDelegate
  hash
  id
  timestamp
  toDelegate
}

type LockerKickRewardTransaction implements LockerTransaction {
  auraLocker: AuraLocker!
  auraLockerAccount: AuraLockerAccount!
  hash: Bytes!
  id: ID!
  kicked: Bytes!
  reward: BigInt!
  timestamp: Int!
}

input LockerKickRewardTransaction_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  auraLocker: String
  auraLockerAccount: String
  auraLockerAccount_: AuraLockerAccount_filter
  auraLockerAccount_contains: String
  auraLockerAccount_contains_nocase: String
  auraLockerAccount_ends_with: String
  auraLockerAccount_ends_with_nocase: String
  auraLockerAccount_gt: String
  auraLockerAccount_gte: String
  auraLockerAccount_in: [String!]
  auraLockerAccount_lt: String
  auraLockerAccount_lte: String
  auraLockerAccount_not: String
  auraLockerAccount_not_contains: String
  auraLockerAccount_not_contains_nocase: String
  auraLockerAccount_not_ends_with: String
  auraLockerAccount_not_ends_with_nocase: String
  auraLockerAccount_not_in: [String!]
  auraLockerAccount_not_starts_with: String
  auraLockerAccount_not_starts_with_nocase: String
  auraLockerAccount_starts_with: String
  auraLockerAccount_starts_with_nocase: String
  auraLocker_: AuraLocker_filter
  auraLocker_contains: String
  auraLocker_contains_nocase: String
  auraLocker_ends_with: String
  auraLocker_ends_with_nocase: String
  auraLocker_gt: String
  auraLocker_gte: String
  auraLocker_in: [String!]
  auraLocker_lt: String
  auraLocker_lte: String
  auraLocker_not: String
  auraLocker_not_contains: String
  auraLocker_not_contains_nocase: String
  auraLocker_not_ends_with: String
  auraLocker_not_ends_with_nocase: String
  auraLocker_not_in: [String!]
  auraLocker_not_starts_with: String
  auraLocker_not_starts_with_nocase: String
  auraLocker_starts_with: String
  auraLocker_starts_with_nocase: String
  hash: Bytes
  hash_contains: Bytes
  hash_in: [Bytes!]
  hash_not: Bytes
  hash_not_contains: Bytes
  hash_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  kicked: Bytes
  kicked_contains: Bytes
  kicked_in: [Bytes!]
  kicked_not: Bytes
  kicked_not_contains: Bytes
  kicked_not_in: [Bytes!]
  reward: BigInt
  reward_gt: BigInt
  reward_gte: BigInt
  reward_in: [BigInt!]
  reward_lt: BigInt
  reward_lte: BigInt
  reward_not: BigInt
  reward_not_in: [BigInt!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
}

enum LockerKickRewardTransaction_orderBy {
  auraLocker
  auraLockerAccount
  hash
  id
  kicked
  reward
  timestamp
}

type LockerRewardPaidTransaction implements LockerTransaction {
  auraLocker: AuraLocker!
  auraLockerAccount: AuraLockerAccount!
  hash: Bytes!
  id: ID!
  reward: BigInt!
  rewardToken: Token!
  timestamp: Int!
}

input LockerRewardPaidTransaction_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  auraLocker: String
  auraLockerAccount: String
  auraLockerAccount_: AuraLockerAccount_filter
  auraLockerAccount_contains: String
  auraLockerAccount_contains_nocase: String
  auraLockerAccount_ends_with: String
  auraLockerAccount_ends_with_nocase: String
  auraLockerAccount_gt: String
  auraLockerAccount_gte: String
  auraLockerAccount_in: [String!]
  auraLockerAccount_lt: String
  auraLockerAccount_lte: String
  auraLockerAccount_not: String
  auraLockerAccount_not_contains: String
  auraLockerAccount_not_contains_nocase: String
  auraLockerAccount_not_ends_with: String
  auraLockerAccount_not_ends_with_nocase: String
  auraLockerAccount_not_in: [String!]
  auraLockerAccount_not_starts_with: String
  auraLockerAccount_not_starts_with_nocase: String
  auraLockerAccount_starts_with: String
  auraLockerAccount_starts_with_nocase: String
  auraLocker_: AuraLocker_filter
  auraLocker_contains: String
  auraLocker_contains_nocase: String
  auraLocker_ends_with: String
  auraLocker_ends_with_nocase: String
  auraLocker_gt: String
  auraLocker_gte: String
  auraLocker_in: [String!]
  auraLocker_lt: String
  auraLocker_lte: String
  auraLocker_not: String
  auraLocker_not_contains: String
  auraLocker_not_contains_nocase: String
  auraLocker_not_ends_with: String
  auraLocker_not_ends_with_nocase: String
  auraLocker_not_in: [String!]
  auraLocker_not_starts_with: String
  auraLocker_not_starts_with_nocase: String
  auraLocker_starts_with: String
  auraLocker_starts_with_nocase: String
  hash: Bytes
  hash_contains: Bytes
  hash_in: [Bytes!]
  hash_not: Bytes
  hash_not_contains: Bytes
  hash_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  reward: BigInt
  rewardToken: String
  rewardToken_: Token_filter
  rewardToken_contains: String
  rewardToken_contains_nocase: String
  rewardToken_ends_with: String
  rewardToken_ends_with_nocase: String
  rewardToken_gt: String
  rewardToken_gte: String
  rewardToken_in: [String!]
  rewardToken_lt: String
  rewardToken_lte: String
  rewardToken_not: String
  rewardToken_not_contains: String
  rewardToken_not_contains_nocase: String
  rewardToken_not_ends_with: String
  rewardToken_not_ends_with_nocase: String
  rewardToken_not_in: [String!]
  rewardToken_not_starts_with: String
  rewardToken_not_starts_with_nocase: String
  rewardToken_starts_with: String
  rewardToken_starts_with_nocase: String
  reward_gt: BigInt
  reward_gte: BigInt
  reward_in: [BigInt!]
  reward_lt: BigInt
  reward_lte: BigInt
  reward_not: BigInt
  reward_not_in: [BigInt!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
}

enum LockerRewardPaidTransaction_orderBy {
  auraLocker
  auraLockerAccount
  hash
  id
  reward
  rewardToken
  timestamp
}

type LockerStakedTransaction implements LockerTransaction {
  auraLocker: AuraLocker!
  auraLockerAccount: AuraLockerAccount!
  hash: Bytes!
  id: ID!
  lockedAmount: BigInt!
  paidAmount: BigInt!
  timestamp: Int!
}

input LockerStakedTransaction_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  auraLocker: String
  auraLockerAccount: String
  auraLockerAccount_: AuraLockerAccount_filter
  auraLockerAccount_contains: String
  auraLockerAccount_contains_nocase: String
  auraLockerAccount_ends_with: String
  auraLockerAccount_ends_with_nocase: String
  auraLockerAccount_gt: String
  auraLockerAccount_gte: String
  auraLockerAccount_in: [String!]
  auraLockerAccount_lt: String
  auraLockerAccount_lte: String
  auraLockerAccount_not: String
  auraLockerAccount_not_contains: String
  auraLockerAccount_not_contains_nocase: String
  auraLockerAccount_not_ends_with: String
  auraLockerAccount_not_ends_with_nocase: String
  auraLockerAccount_not_in: [String!]
  auraLockerAccount_not_starts_with: String
  auraLockerAccount_not_starts_with_nocase: String
  auraLockerAccount_starts_with: String
  auraLockerAccount_starts_with_nocase: String
  auraLocker_: AuraLocker_filter
  auraLocker_contains: String
  auraLocker_contains_nocase: String
  auraLocker_ends_with: String
  auraLocker_ends_with_nocase: String
  auraLocker_gt: String
  auraLocker_gte: String
  auraLocker_in: [String!]
  auraLocker_lt: String
  auraLocker_lte: String
  auraLocker_not: String
  auraLocker_not_contains: String
  auraLocker_not_contains_nocase: String
  auraLocker_not_ends_with: String
  auraLocker_not_ends_with_nocase: String
  auraLocker_not_in: [String!]
  auraLocker_not_starts_with: String
  auraLocker_not_starts_with_nocase: String
  auraLocker_starts_with: String
  auraLocker_starts_with_nocase: String
  hash: Bytes
  hash_contains: Bytes
  hash_in: [Bytes!]
  hash_not: Bytes
  hash_not_contains: Bytes
  hash_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lockedAmount: BigInt
  lockedAmount_gt: BigInt
  lockedAmount_gte: BigInt
  lockedAmount_in: [BigInt!]
  lockedAmount_lt: BigInt
  lockedAmount_lte: BigInt
  lockedAmount_not: BigInt
  lockedAmount_not_in: [BigInt!]
  paidAmount: BigInt
  paidAmount_gt: BigInt
  paidAmount_gte: BigInt
  paidAmount_in: [BigInt!]
  paidAmount_lt: BigInt
  paidAmount_lte: BigInt
  paidAmount_not: BigInt
  paidAmount_not_in: [BigInt!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
}

enum LockerStakedTransaction_orderBy {
  auraLocker
  auraLockerAccount
  hash
  id
  lockedAmount
  paidAmount
  timestamp
}

interface LockerTransaction {
  auraLocker: AuraLocker!
  auraLockerAccount: AuraLockerAccount!
  hash: Bytes!
  id: ID!
  timestamp: Int!
}

input LockerTransaction_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  auraLocker: String
  auraLockerAccount: String
  auraLockerAccount_: AuraLockerAccount_filter
  auraLockerAccount_contains: String
  auraLockerAccount_contains_nocase: String
  auraLockerAccount_ends_with: String
  auraLockerAccount_ends_with_nocase: String
  auraLockerAccount_gt: String
  auraLockerAccount_gte: String
  auraLockerAccount_in: [String!]
  auraLockerAccount_lt: String
  auraLockerAccount_lte: String
  auraLockerAccount_not: String
  auraLockerAccount_not_contains: String
  auraLockerAccount_not_contains_nocase: String
  auraLockerAccount_not_ends_with: String
  auraLockerAccount_not_ends_with_nocase: String
  auraLockerAccount_not_in: [String!]
  auraLockerAccount_not_starts_with: String
  auraLockerAccount_not_starts_with_nocase: String
  auraLockerAccount_starts_with: String
  auraLockerAccount_starts_with_nocase: String
  auraLocker_: AuraLocker_filter
  auraLocker_contains: String
  auraLocker_contains_nocase: String
  auraLocker_ends_with: String
  auraLocker_ends_with_nocase: String
  auraLocker_gt: String
  auraLocker_gte: String
  auraLocker_in: [String!]
  auraLocker_lt: String
  auraLocker_lte: String
  auraLocker_not: String
  auraLocker_not_contains: String
  auraLocker_not_contains_nocase: String
  auraLocker_not_ends_with: String
  auraLocker_not_ends_with_nocase: String
  auraLocker_not_in: [String!]
  auraLocker_not_starts_with: String
  auraLocker_not_starts_with_nocase: String
  auraLocker_starts_with: String
  auraLocker_starts_with_nocase: String
  hash: Bytes
  hash_contains: Bytes
  hash_in: [Bytes!]
  hash_not: Bytes
  hash_not_contains: Bytes
  hash_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
}

enum LockerTransaction_orderBy {
  auraLocker
  auraLockerAccount
  hash
  id
  timestamp
}

type LockerWithdrawnTransaction implements LockerTransaction {
  amount: BigInt!
  auraLocker: AuraLocker!
  auraLockerAccount: AuraLockerAccount!
  hash: Bytes!
  id: ID!
  relocked: Boolean!
  timestamp: Int!
}

input LockerWithdrawnTransaction_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  auraLocker: String
  auraLockerAccount: String
  auraLockerAccount_: AuraLockerAccount_filter
  auraLockerAccount_contains: String
  auraLockerAccount_contains_nocase: String
  auraLockerAccount_ends_with: String
  auraLockerAccount_ends_with_nocase: String
  auraLockerAccount_gt: String
  auraLockerAccount_gte: String
  auraLockerAccount_in: [String!]
  auraLockerAccount_lt: String
  auraLockerAccount_lte: String
  auraLockerAccount_not: String
  auraLockerAccount_not_contains: String
  auraLockerAccount_not_contains_nocase: String
  auraLockerAccount_not_ends_with: String
  auraLockerAccount_not_ends_with_nocase: String
  auraLockerAccount_not_in: [String!]
  auraLockerAccount_not_starts_with: String
  auraLockerAccount_not_starts_with_nocase: String
  auraLockerAccount_starts_with: String
  auraLockerAccount_starts_with_nocase: String
  auraLocker_: AuraLocker_filter
  auraLocker_contains: String
  auraLocker_contains_nocase: String
  auraLocker_ends_with: String
  auraLocker_ends_with_nocase: String
  auraLocker_gt: String
  auraLocker_gte: String
  auraLocker_in: [String!]
  auraLocker_lt: String
  auraLocker_lte: String
  auraLocker_not: String
  auraLocker_not_contains: String
  auraLocker_not_contains_nocase: String
  auraLocker_not_ends_with: String
  auraLocker_not_ends_with_nocase: String
  auraLocker_not_in: [String!]
  auraLocker_not_starts_with: String
  auraLocker_not_starts_with_nocase: String
  auraLocker_starts_with: String
  auraLocker_starts_with_nocase: String
  hash: Bytes
  hash_contains: Bytes
  hash_in: [Bytes!]
  hash_not: Bytes
  hash_not_contains: Bytes
  hash_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  relocked: Boolean
  relocked_in: [Boolean!]
  relocked_not: Boolean
  relocked_not_in: [Boolean!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
}

enum LockerWithdrawnTransaction_orderBy {
  amount
  auraLocker
  auraLockerAccount
  hash
  id
  relocked
  timestamp
}

type ManagementOperation {
  cashDelta: BigDecimal!
  id: ID!
  managedDelta: BigDecimal!
  poolTokenId: PoolToken!
  timestamp: Int!
  type: OperationType!
}

input ManagementOperation_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [ManagementOperation_filter]
  cashDelta: BigDecimal
  cashDelta_gt: BigDecimal
  cashDelta_gte: BigDecimal
  cashDelta_in: [BigDecimal!]
  cashDelta_lt: BigDecimal
  cashDelta_lte: BigDecimal
  cashDelta_not: BigDecimal
  cashDelta_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  managedDelta: BigDecimal
  managedDelta_gt: BigDecimal
  managedDelta_gte: BigDecimal
  managedDelta_in: [BigDecimal!]
  managedDelta_lt: BigDecimal
  managedDelta_lte: BigDecimal
  managedDelta_not: BigDecimal
  managedDelta_not_in: [BigDecimal!]
  or: [ManagementOperation_filter]
  poolTokenId: String
  poolTokenId_: PoolToken_filter
  poolTokenId_contains: String
  poolTokenId_contains_nocase: String
  poolTokenId_ends_with: String
  poolTokenId_ends_with_nocase: String
  poolTokenId_gt: String
  poolTokenId_gte: String
  poolTokenId_in: [String!]
  poolTokenId_lt: String
  poolTokenId_lte: String
  poolTokenId_not: String
  poolTokenId_not_contains: String
  poolTokenId_not_contains_nocase: String
  poolTokenId_not_ends_with: String
  poolTokenId_not_ends_with_nocase: String
  poolTokenId_not_in: [String!]
  poolTokenId_not_starts_with: String
  poolTokenId_not_starts_with_nocase: String
  poolTokenId_starts_with: String
  poolTokenId_starts_with_nocase: String
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  type: OperationType
  type_in: [OperationType!]
  type_not: OperationType
  type_not_in: [OperationType!]
}

enum ManagementOperation_orderBy {
  cashDelta
  id
  managedDelta
  poolTokenId
  poolTokenId__address
  poolTokenId__assetManager
  poolTokenId__balance
  poolTokenId__cashBalance
  poolTokenId__decimals
  poolTokenId__id
  poolTokenId__index
  poolTokenId__isExemptFromYieldProtocolFee
  poolTokenId__managedBalance
  poolTokenId__name
  poolTokenId__oldPriceRate
  poolTokenId__priceRate
  poolTokenId__symbol
  poolTokenId__weight
  timestamp
  type
}

type MasterChef {
  endBlock: BigInt!

  """
  Address
  """
  id: ID!
  poolInfos(
    first: Int = 100
    orderBy: MasterChefPoolInfo_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: MasterChefPoolInfo_filter
  ): [MasterChefPoolInfo!]!
  rewardPerBlock: BigInt!
  startBlock: BigInt!
  totalAllocPoint: BigInt!
  userInfos(
    first: Int = 100
    orderBy: MasterChefUserInfo_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: MasterChefUserInfo_filter
  ): [MasterChefUserInfo!]!
}

type MasterChefPoolInfo {
  accCvxPerShare: BigInt!
  allocPoint: BigInt!

  """
  Pool ID (pid)
  """
  id: ID!
  lastRewardBlock: BigInt!
  lpSupply: BigInt!
  lpToken: Token!
  masterChef: MasterChef!
  rewarder: Bytes!
  userInfos(
    first: Int = 100
    orderBy: MasterChefUserInfo_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: MasterChefUserInfo_filter
  ): [MasterChefUserInfo!]!
}

input MasterChefPoolInfo_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  accCvxPerShare: BigInt
  accCvxPerShare_gt: BigInt
  accCvxPerShare_gte: BigInt
  accCvxPerShare_in: [BigInt!]
  accCvxPerShare_lt: BigInt
  accCvxPerShare_lte: BigInt
  accCvxPerShare_not: BigInt
  accCvxPerShare_not_in: [BigInt!]
  allocPoint: BigInt
  allocPoint_gt: BigInt
  allocPoint_gte: BigInt
  allocPoint_in: [BigInt!]
  allocPoint_lt: BigInt
  allocPoint_lte: BigInt
  allocPoint_not: BigInt
  allocPoint_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lastRewardBlock: BigInt
  lastRewardBlock_gt: BigInt
  lastRewardBlock_gte: BigInt
  lastRewardBlock_in: [BigInt!]
  lastRewardBlock_lt: BigInt
  lastRewardBlock_lte: BigInt
  lastRewardBlock_not: BigInt
  lastRewardBlock_not_in: [BigInt!]
  lpSupply: BigInt
  lpSupply_gt: BigInt
  lpSupply_gte: BigInt
  lpSupply_in: [BigInt!]
  lpSupply_lt: BigInt
  lpSupply_lte: BigInt
  lpSupply_not: BigInt
  lpSupply_not_in: [BigInt!]
  lpToken: String
  lpToken_: Token_filter
  lpToken_contains: String
  lpToken_contains_nocase: String
  lpToken_ends_with: String
  lpToken_ends_with_nocase: String
  lpToken_gt: String
  lpToken_gte: String
  lpToken_in: [String!]
  lpToken_lt: String
  lpToken_lte: String
  lpToken_not: String
  lpToken_not_contains: String
  lpToken_not_contains_nocase: String
  lpToken_not_ends_with: String
  lpToken_not_ends_with_nocase: String
  lpToken_not_in: [String!]
  lpToken_not_starts_with: String
  lpToken_not_starts_with_nocase: String
  lpToken_starts_with: String
  lpToken_starts_with_nocase: String
  masterChef: String
  masterChef_: MasterChef_filter
  masterChef_contains: String
  masterChef_contains_nocase: String
  masterChef_ends_with: String
  masterChef_ends_with_nocase: String
  masterChef_gt: String
  masterChef_gte: String
  masterChef_in: [String!]
  masterChef_lt: String
  masterChef_lte: String
  masterChef_not: String
  masterChef_not_contains: String
  masterChef_not_contains_nocase: String
  masterChef_not_ends_with: String
  masterChef_not_ends_with_nocase: String
  masterChef_not_in: [String!]
  masterChef_not_starts_with: String
  masterChef_not_starts_with_nocase: String
  masterChef_starts_with: String
  masterChef_starts_with_nocase: String
  rewarder: Bytes
  rewarder_contains: Bytes
  rewarder_in: [Bytes!]
  rewarder_not: Bytes
  rewarder_not_contains: Bytes
  rewarder_not_in: [Bytes!]
  userInfos_: MasterChefUserInfo_filter
}

enum MasterChefPoolInfo_orderBy {
  accCvxPerShare
  allocPoint
  id
  lastRewardBlock
  lpSupply
  lpToken
  masterChef
  rewarder
  userInfos
}

type MasterChefUserInfo {
  account: Account!
  amount: BigInt!

  """
  ${poolInfo.id}.${account.id}
  """
  id: ID!
  masterChef: MasterChef!
  poolInfo: MasterChefPoolInfo!
  rewardDebt: BigInt!
}

input MasterChefUserInfo_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: String
  account_: Account_filter
  account_contains: String
  account_contains_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_gt: String
  account_gte: String
  account_in: [String!]
  account_lt: String
  account_lte: String
  account_not: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_not_in: [String!]
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  masterChef: String
  masterChef_: MasterChef_filter
  masterChef_contains: String
  masterChef_contains_nocase: String
  masterChef_ends_with: String
  masterChef_ends_with_nocase: String
  masterChef_gt: String
  masterChef_gte: String
  masterChef_in: [String!]
  masterChef_lt: String
  masterChef_lte: String
  masterChef_not: String
  masterChef_not_contains: String
  masterChef_not_contains_nocase: String
  masterChef_not_ends_with: String
  masterChef_not_ends_with_nocase: String
  masterChef_not_in: [String!]
  masterChef_not_starts_with: String
  masterChef_not_starts_with_nocase: String
  masterChef_starts_with: String
  masterChef_starts_with_nocase: String
  poolInfo: String
  poolInfo_: MasterChefPoolInfo_filter
  poolInfo_contains: String
  poolInfo_contains_nocase: String
  poolInfo_ends_with: String
  poolInfo_ends_with_nocase: String
  poolInfo_gt: String
  poolInfo_gte: String
  poolInfo_in: [String!]
  poolInfo_lt: String
  poolInfo_lte: String
  poolInfo_not: String
  poolInfo_not_contains: String
  poolInfo_not_contains_nocase: String
  poolInfo_not_ends_with: String
  poolInfo_not_ends_with_nocase: String
  poolInfo_not_in: [String!]
  poolInfo_not_starts_with: String
  poolInfo_not_starts_with_nocase: String
  poolInfo_starts_with: String
  poolInfo_starts_with_nocase: String
  rewardDebt: BigInt
  rewardDebt_gt: BigInt
  rewardDebt_gte: BigInt
  rewardDebt_in: [BigInt!]
  rewardDebt_lt: BigInt
  rewardDebt_lte: BigInt
  rewardDebt_not: BigInt
  rewardDebt_not_in: [BigInt!]
}

enum MasterChefUserInfo_orderBy {
  account
  amount
  id
  masterChef
  poolInfo
  rewardDebt
}

input MasterChef_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  endBlock: BigInt
  endBlock_gt: BigInt
  endBlock_gte: BigInt
  endBlock_in: [BigInt!]
  endBlock_lt: BigInt
  endBlock_lte: BigInt
  endBlock_not: BigInt
  endBlock_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  poolInfos_: MasterChefPoolInfo_filter
  rewardPerBlock: BigInt
  rewardPerBlock_gt: BigInt
  rewardPerBlock_gte: BigInt
  rewardPerBlock_in: [BigInt!]
  rewardPerBlock_lt: BigInt
  rewardPerBlock_lte: BigInt
  rewardPerBlock_not: BigInt
  rewardPerBlock_not_in: [BigInt!]
  startBlock: BigInt
  startBlock_gt: BigInt
  startBlock_gte: BigInt
  startBlock_in: [BigInt!]
  startBlock_lt: BigInt
  startBlock_lte: BigInt
  startBlock_not: BigInt
  startBlock_not_in: [BigInt!]
  totalAllocPoint: BigInt
  totalAllocPoint_gt: BigInt
  totalAllocPoint_gte: BigInt
  totalAllocPoint_in: [BigInt!]
  totalAllocPoint_lt: BigInt
  totalAllocPoint_lte: BigInt
  totalAllocPoint_not: BigInt
  totalAllocPoint_not_in: [BigInt!]
  userInfos_: MasterChefUserInfo_filter
}

enum MasterChef_orderBy {
  endBlock
  id
  poolInfos
  rewardPerBlock
  startBlock
  totalAllocPoint
  userInfos
}

type MerkleDrop {
  claims(
    first: Int = 100
    orderBy: MerkleDropClaim_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: MerkleDropClaim_filter
  ): [MerkleDropClaim!]!
  expiryTime: Int!

  """
  Address
  """
  id: ID!
  merkleRoot: Bytes!
  startTime: Int!
}

type MerkleDropClaim {
  account: Account!
  amount: BigInt!

  """
  {merkleDrop.id}.{account.id}
  """
  id: ID!
  locked: Boolean!
  merkleDrop: MerkleDrop!
}

input MerkleDropClaim_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: String
  account_: Account_filter
  account_contains: String
  account_contains_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_gt: String
  account_gte: String
  account_in: [String!]
  account_lt: String
  account_lte: String
  account_not: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_not_in: [String!]
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  locked: Boolean
  locked_in: [Boolean!]
  locked_not: Boolean
  locked_not_in: [Boolean!]
  merkleDrop: String
  merkleDrop_: MerkleDrop_filter
  merkleDrop_contains: String
  merkleDrop_contains_nocase: String
  merkleDrop_ends_with: String
  merkleDrop_ends_with_nocase: String
  merkleDrop_gt: String
  merkleDrop_gte: String
  merkleDrop_in: [String!]
  merkleDrop_lt: String
  merkleDrop_lte: String
  merkleDrop_not: String
  merkleDrop_not_contains: String
  merkleDrop_not_contains_nocase: String
  merkleDrop_not_ends_with: String
  merkleDrop_not_ends_with_nocase: String
  merkleDrop_not_in: [String!]
  merkleDrop_not_starts_with: String
  merkleDrop_not_starts_with_nocase: String
  merkleDrop_starts_with: String
  merkleDrop_starts_with_nocase: String
}

enum MerkleDropClaim_orderBy {
  account
  amount
  id
  locked
  merkleDrop
}

input MerkleDrop_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  claims_: MerkleDropClaim_filter
  expiryTime: Int
  expiryTime_gt: Int
  expiryTime_gte: Int
  expiryTime_in: [Int!]
  expiryTime_lt: Int
  expiryTime_lte: Int
  expiryTime_not: Int
  expiryTime_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  merkleRoot: Bytes
  merkleRoot_contains: Bytes
  merkleRoot_in: [Bytes!]
  merkleRoot_not: Bytes
  merkleRoot_not_contains: Bytes
  merkleRoot_not_in: [Bytes!]
  startTime: Int
  startTime_gt: Int
  startTime_gte: Int
  startTime_in: [Int!]
  startTime_lt: Int
  startTime_lte: Int
  startTime_not: Int
  startTime_not_in: [Int!]
}

enum MerkleDrop_orderBy {
  claims
  expiryTime
  id
  merkleRoot
  startTime
}

enum OperationType {
  Deposit
  Update
  Withdraw
}

"""
Defines the order direction, either ascending or descending
"""
enum OrderDirection {
  asc
  desc
}

type Pool {
  accounts(
    first: Int = 100
    orderBy: PoolAccount_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: PoolAccount_filter
  ): [PoolAccount!]!
  address: Bytes!
  alpha: BigDecimal
  amp: BigInt
  baseToken: Bytes
  beta: BigDecimal
  c: BigDecimal
  createTime: Int!
  dSq: BigDecimal
  delta: BigDecimal

  """
  The Aura deposit token; a 1:1 token representing an LP deposit.
  - Factory pools    => an auraLP token
  - auraBAL staking  => auraBAL
  """
  depositToken: Token!
  epsilon: BigDecimal
  expiryTime: BigInt
  factory: Bytes
  factoryPoolData: FactoryPoolData

  """
  Gauge associated with the pool
  """
  gauge: Gauge
  historicalValues(
    first: Int = 100
    orderBy: PoolHistoricalLiquidity_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: PoolHistoricalLiquidity_filter
  ): [PoolHistoricalLiquidity!]
  holdersCount: BigInt!

  """
  Pool ID (pid)
  """
  id: ID!
  isFactoryPool: Boolean!
  isInRecoveryMode: Boolean
  isPaused: Boolean
  lambda: BigDecimal
  lastPostJoinExitInvariant: BigDecimal
  lowerTarget: BigDecimal

  """
  LP Token refers to:
  - Factory pools    => e.g. a given BPT
  - auraBAL staking  => BAL
  """
  lpToken: Token!
  mainIndex: Int
  managementFee: BigDecimal
  name: String
  oracleEnabled: Boolean!
  owner: Bytes
  poolType: String
  poolTypeVersion: Int
  priceRateProviders(
    first: Int = 100
    orderBy: PriceRateProvider_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: PriceRateProvider_filter
  ): [PriceRateProvider!]
  principalToken: Bytes
  protocolAumFeeCache: BigDecimal
  protocolId: Int
  protocolIdData: ProtocolIdData
  protocolSwapFeeCache: BigDecimal
  protocolYieldFeeCache: BigDecimal

  """
  List of rewards per-token
  """
  rewardData(
    first: Int = 100
    orderBy: PoolRewardData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: PoolRewardData_filter
  ): [PoolRewardData!]!

  """
  Reward paid transactions for this pool
  """
  rewardPaidTransactions(
    first: Int = 100
    orderBy: PoolRewardPaidTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: PoolRewardPaidTransaction_filter
  ): [PoolRewardPaidTransaction!]!

  """
  BaseRewardPool
  """
  rewardPool: Bytes!

  """
  Reward token of BaseRewardPool
  """
  rewardToken: Token!
  root3Alpha: BigDecimal
  s: BigDecimal
  shares(
    first: Int = 100
    orderBy: PoolShare_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: PoolShare_filter
  ): [PoolShare!]
  snapshots(
    first: Int = 100
    orderBy: PoolSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: PoolSnapshot_filter
  ): [PoolSnapshot!]
  sqrtAlpha: BigDecimal
  sqrtBeta: BigDecimal

  """
  Staked transactions for this pool
  """
  stakedTransactions(
    first: Int = 100
    orderBy: PoolStakedTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: PoolStakedTransaction_filter
  ): [PoolStakedTransaction!]!

  """
  auraBal initial staking only
  """
  startTime: Int
  strategyType: Int!
  swapEnabled: Boolean!
  swapFee: BigDecimal!
  swaps(
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Swap_filter
  ): [Swap!]
  swapsCount: BigInt!
  symbol: String
  tauAlphaX: BigDecimal
  tauAlphaY: BigDecimal
  tauBetaX: BigDecimal
  tauBetaY: BigDecimal
  tokens(
    first: Int = 100
    orderBy: PoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: PoolToken_filter
  ): [PoolToken!]
  tokensList: [Bytes!]!
  totalLiquidity: BigDecimal!
  totalShares: BigDecimal!

  """
  Total staked in the rewardPool
  """
  totalStaked: BigInt!

  """
  Total supply of the depositToken
  """
  totalSupply: BigInt!
  totalSwapFee: BigDecimal!
  totalSwapVolume: BigDecimal!
  totalWeight: BigDecimal
  tx: Bytes
  u: BigDecimal
  unitSeconds: BigInt
  upperTarget: BigDecimal
  v: BigDecimal
  vaultID: Balancer!
  w: BigDecimal
  weightUpdates(
    first: Int = 100
    orderBy: GradualWeightUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: GradualWeightUpdate_filter
  ): [GradualWeightUpdate!]

  """
  Withdrawn transactions for this pool
  """
  withdrawnTransactions(
    first: Int = 100
    orderBy: PoolWithdrawnTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: PoolWithdrawnTransaction_filter
  ): [PoolWithdrawnTransaction!]!
  wrappedIndex: Int
  z: BigDecimal
}

type PoolAccount {
  account: Account!

  """
  {Pool.id}.{Account.id}
  """
  id: ID!
  pool: Pool!

  """
  Reward paid transactions for this pool account
  """
  rewardPaidTransactions(
    first: Int = 100
    orderBy: PoolRewardPaidTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: PoolRewardPaidTransaction_filter
  ): [PoolRewardPaidTransaction!]!
  rewards(
    first: Int = 100
    orderBy: PoolAccountRewards_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: PoolAccountRewards_filter
  ): [PoolAccountRewards!]!

  """
  rewardsPool.balanceOf(account)
  i.e. the account's staked LP tokens
  """
  staked: BigInt!

  """
  Staked transactions for this pool account
  """
  stakedTransactions(
    first: Int = 100
    orderBy: PoolStakedTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: PoolStakedTransaction_filter
  ): [PoolStakedTransaction!]!

  """
  Withdrawn transactions for this pool account
  """
  withdrawnTransactions(
    first: Int = 100
    orderBy: PoolWithdrawnTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: PoolWithdrawnTransaction_filter
  ): [PoolWithdrawnTransaction!]!
}

type PoolAccountRewards {
  """
  {rewardsToken.id}.{poolAccount.id}
  """
  id: ID!
  poolAccount: PoolAccount!

  """
  userRewardPerTokenPaid(account)
  """
  rewardPerTokenPaid: BigInt!
  rewardToken: Token!

  """
  rewards(account)
  """
  rewards: BigInt!
}

input PoolAccountRewards_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  poolAccount: String
  poolAccount_: PoolAccount_filter
  poolAccount_contains: String
  poolAccount_contains_nocase: String
  poolAccount_ends_with: String
  poolAccount_ends_with_nocase: String
  poolAccount_gt: String
  poolAccount_gte: String
  poolAccount_in: [String!]
  poolAccount_lt: String
  poolAccount_lte: String
  poolAccount_not: String
  poolAccount_not_contains: String
  poolAccount_not_contains_nocase: String
  poolAccount_not_ends_with: String
  poolAccount_not_ends_with_nocase: String
  poolAccount_not_in: [String!]
  poolAccount_not_starts_with: String
  poolAccount_not_starts_with_nocase: String
  poolAccount_starts_with: String
  poolAccount_starts_with_nocase: String
  rewardPerTokenPaid: BigInt
  rewardPerTokenPaid_gt: BigInt
  rewardPerTokenPaid_gte: BigInt
  rewardPerTokenPaid_in: [BigInt!]
  rewardPerTokenPaid_lt: BigInt
  rewardPerTokenPaid_lte: BigInt
  rewardPerTokenPaid_not: BigInt
  rewardPerTokenPaid_not_in: [BigInt!]
  rewardToken: String
  rewardToken_: Token_filter
  rewardToken_contains: String
  rewardToken_contains_nocase: String
  rewardToken_ends_with: String
  rewardToken_ends_with_nocase: String
  rewardToken_gt: String
  rewardToken_gte: String
  rewardToken_in: [String!]
  rewardToken_lt: String
  rewardToken_lte: String
  rewardToken_not: String
  rewardToken_not_contains: String
  rewardToken_not_contains_nocase: String
  rewardToken_not_ends_with: String
  rewardToken_not_ends_with_nocase: String
  rewardToken_not_in: [String!]
  rewardToken_not_starts_with: String
  rewardToken_not_starts_with_nocase: String
  rewardToken_starts_with: String
  rewardToken_starts_with_nocase: String
  rewards: BigInt
  rewards_gt: BigInt
  rewards_gte: BigInt
  rewards_in: [BigInt!]
  rewards_lt: BigInt
  rewards_lte: BigInt
  rewards_not: BigInt
  rewards_not_in: [BigInt!]
}

enum PoolAccountRewards_orderBy {
  id
  poolAccount
  rewardPerTokenPaid
  rewardToken
  rewards
}

input PoolAccount_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: String
  account_: Account_filter
  account_contains: String
  account_contains_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_gt: String
  account_gte: String
  account_in: [String!]
  account_lt: String
  account_lte: String
  account_not: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_not_in: [String!]
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  rewardPaidTransactions_: PoolRewardPaidTransaction_filter
  rewards_: PoolAccountRewards_filter
  staked: BigInt
  stakedTransactions_: PoolStakedTransaction_filter
  staked_gt: BigInt
  staked_gte: BigInt
  staked_in: [BigInt!]
  staked_lt: BigInt
  staked_lte: BigInt
  staked_not: BigInt
  staked_not_in: [BigInt!]
  withdrawnTransactions_: PoolWithdrawnTransaction_filter
}

enum PoolAccount_orderBy {
  account
  id
  pool
  rewardPaidTransactions
  rewards
  staked
  stakedTransactions
  withdrawnTransactions
}

type PoolContract {
  id: ID!
  pool: Pool!
}

input PoolContract_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [PoolContract_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [PoolContract_filter]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
}

enum PoolContract_orderBy {
  id
  pool
  pool__address
  pool__alpha
  pool__amp
  pool__baseToken
  pool__beta
  pool__c
  pool__createTime
  pool__dSq
  pool__delta
  pool__epsilon
  pool__expiryTime
  pool__factory
  pool__holdersCount
  pool__id
  pool__isInRecoveryMode
  pool__isPaused
  pool__lambda
  pool__lastPostJoinExitInvariant
  pool__lowerTarget
  pool__mainIndex
  pool__managementFee
  pool__name
  pool__oracleEnabled
  pool__owner
  pool__poolType
  pool__poolTypeVersion
  pool__principalToken
  pool__protocolAumFeeCache
  pool__protocolId
  pool__protocolSwapFeeCache
  pool__protocolYieldFeeCache
  pool__root3Alpha
  pool__s
  pool__sqrtAlpha
  pool__sqrtBeta
  pool__strategyType
  pool__swapEnabled
  pool__swapFee
  pool__swapsCount
  pool__symbol
  pool__tauAlphaX
  pool__tauAlphaY
  pool__tauBetaX
  pool__tauBetaY
  pool__totalLiquidity
  pool__totalShares
  pool__totalSwapFee
  pool__totalSwapVolume
  pool__totalWeight
  pool__tx
  pool__u
  pool__unitSeconds
  pool__upperTarget
  pool__v
  pool__w
  pool__wrappedIndex
  pool__z
}

type PoolHistoricalLiquidity {
  block: BigInt!
  id: ID!
  poolId: Pool!
  poolLiquidity: BigDecimal!
  poolShareValue: BigDecimal!
  poolTotalShares: BigDecimal!
  pricingAsset: Bytes!
}

input PoolHistoricalLiquidity_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [PoolHistoricalLiquidity_filter]
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [PoolHistoricalLiquidity_filter]
  poolId: String
  poolId_: Pool_filter
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_gt: String
  poolId_gte: String
  poolId_in: [String!]
  poolId_lt: String
  poolId_lte: String
  poolId_not: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  poolId_not_in: [String!]
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  poolLiquidity: BigDecimal
  poolLiquidity_gt: BigDecimal
  poolLiquidity_gte: BigDecimal
  poolLiquidity_in: [BigDecimal!]
  poolLiquidity_lt: BigDecimal
  poolLiquidity_lte: BigDecimal
  poolLiquidity_not: BigDecimal
  poolLiquidity_not_in: [BigDecimal!]
  poolShareValue: BigDecimal
  poolShareValue_gt: BigDecimal
  poolShareValue_gte: BigDecimal
  poolShareValue_in: [BigDecimal!]
  poolShareValue_lt: BigDecimal
  poolShareValue_lte: BigDecimal
  poolShareValue_not: BigDecimal
  poolShareValue_not_in: [BigDecimal!]
  poolTotalShares: BigDecimal
  poolTotalShares_gt: BigDecimal
  poolTotalShares_gte: BigDecimal
  poolTotalShares_in: [BigDecimal!]
  poolTotalShares_lt: BigDecimal
  poolTotalShares_lte: BigDecimal
  poolTotalShares_not: BigDecimal
  poolTotalShares_not_in: [BigDecimal!]
  pricingAsset: Bytes
  pricingAsset_contains: Bytes
  pricingAsset_gt: Bytes
  pricingAsset_gte: Bytes
  pricingAsset_in: [Bytes!]
  pricingAsset_lt: Bytes
  pricingAsset_lte: Bytes
  pricingAsset_not: Bytes
  pricingAsset_not_contains: Bytes
  pricingAsset_not_in: [Bytes!]
}

enum PoolHistoricalLiquidity_orderBy {
  block
  id
  poolId
  poolId__address
  poolId__alpha
  poolId__amp
  poolId__baseToken
  poolId__beta
  poolId__c
  poolId__createTime
  poolId__dSq
  poolId__delta
  poolId__epsilon
  poolId__expiryTime
  poolId__factory
  poolId__holdersCount
  poolId__id
  poolId__isInRecoveryMode
  poolId__isPaused
  poolId__lambda
  poolId__lastPostJoinExitInvariant
  poolId__lowerTarget
  poolId__mainIndex
  poolId__managementFee
  poolId__name
  poolId__oracleEnabled
  poolId__owner
  poolId__poolType
  poolId__poolTypeVersion
  poolId__principalToken
  poolId__protocolAumFeeCache
  poolId__protocolId
  poolId__protocolSwapFeeCache
  poolId__protocolYieldFeeCache
  poolId__root3Alpha
  poolId__s
  poolId__sqrtAlpha
  poolId__sqrtBeta
  poolId__strategyType
  poolId__swapEnabled
  poolId__swapFee
  poolId__swapsCount
  poolId__symbol
  poolId__tauAlphaX
  poolId__tauAlphaY
  poolId__tauBetaX
  poolId__tauBetaY
  poolId__totalLiquidity
  poolId__totalShares
  poolId__totalSwapFee
  poolId__totalSwapVolume
  poolId__totalWeight
  poolId__tx
  poolId__u
  poolId__unitSeconds
  poolId__upperTarget
  poolId__v
  poolId__w
  poolId__wrappedIndex
  poolId__z
  poolLiquidity
  poolShareValue
  poolTotalShares
  pricingAsset
}

type PoolRewardData implements RewardData {
  """
  {pool.id}.{token.id}
  """
  id: ID!
  lastUpdateTime: Int!
  periodFinish: Int!
  pool: Pool!
  queuedRewards: BigInt!
  rewardPerTokenStored: BigInt!
  rewardRate: BigInt!
  token: Token!
}

input PoolRewardData_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lastUpdateTime: Int
  lastUpdateTime_gt: Int
  lastUpdateTime_gte: Int
  lastUpdateTime_in: [Int!]
  lastUpdateTime_lt: Int
  lastUpdateTime_lte: Int
  lastUpdateTime_not: Int
  lastUpdateTime_not_in: [Int!]
  periodFinish: Int
  periodFinish_gt: Int
  periodFinish_gte: Int
  periodFinish_in: [Int!]
  periodFinish_lt: Int
  periodFinish_lte: Int
  periodFinish_not: Int
  periodFinish_not_in: [Int!]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  queuedRewards: BigInt
  queuedRewards_gt: BigInt
  queuedRewards_gte: BigInt
  queuedRewards_in: [BigInt!]
  queuedRewards_lt: BigInt
  queuedRewards_lte: BigInt
  queuedRewards_not: BigInt
  queuedRewards_not_in: [BigInt!]
  rewardPerTokenStored: BigInt
  rewardPerTokenStored_gt: BigInt
  rewardPerTokenStored_gte: BigInt
  rewardPerTokenStored_in: [BigInt!]
  rewardPerTokenStored_lt: BigInt
  rewardPerTokenStored_lte: BigInt
  rewardPerTokenStored_not: BigInt
  rewardPerTokenStored_not_in: [BigInt!]
  rewardRate: BigInt
  rewardRate_gt: BigInt
  rewardRate_gte: BigInt
  rewardRate_in: [BigInt!]
  rewardRate_lt: BigInt
  rewardRate_lte: BigInt
  rewardRate_not: BigInt
  rewardRate_not_in: [BigInt!]
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
}

enum PoolRewardData_orderBy {
  id
  lastUpdateTime
  periodFinish
  pool
  queuedRewards
  rewardPerTokenStored
  rewardRate
  token
}

type PoolRewardPaidTransaction implements PoolTransaction {
  hash: Bytes!
  id: ID!
  pool: Pool!
  poolAccount: PoolAccount!
  reward: BigInt!
  timestamp: Int!
}

input PoolRewardPaidTransaction_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  hash: Bytes
  hash_contains: Bytes
  hash_in: [Bytes!]
  hash_not: Bytes
  hash_not_contains: Bytes
  hash_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  pool: String
  poolAccount: String
  poolAccount_: PoolAccount_filter
  poolAccount_contains: String
  poolAccount_contains_nocase: String
  poolAccount_ends_with: String
  poolAccount_ends_with_nocase: String
  poolAccount_gt: String
  poolAccount_gte: String
  poolAccount_in: [String!]
  poolAccount_lt: String
  poolAccount_lte: String
  poolAccount_not: String
  poolAccount_not_contains: String
  poolAccount_not_contains_nocase: String
  poolAccount_not_ends_with: String
  poolAccount_not_ends_with_nocase: String
  poolAccount_not_in: [String!]
  poolAccount_not_starts_with: String
  poolAccount_not_starts_with_nocase: String
  poolAccount_starts_with: String
  poolAccount_starts_with_nocase: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  reward: BigInt
  reward_gt: BigInt
  reward_gte: BigInt
  reward_in: [BigInt!]
  reward_lt: BigInt
  reward_lte: BigInt
  reward_not: BigInt
  reward_not_in: [BigInt!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
}

enum PoolRewardPaidTransaction_orderBy {
  hash
  id
  pool
  poolAccount
  reward
  timestamp
}

type PoolShare {
  balance: BigDecimal!
  id: ID!
  poolId: Pool!
  userAddress: User!
}

input PoolShare_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [PoolShare_filter]
  balance: BigDecimal
  balance_gt: BigDecimal
  balance_gte: BigDecimal
  balance_in: [BigDecimal!]
  balance_lt: BigDecimal
  balance_lte: BigDecimal
  balance_not: BigDecimal
  balance_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [PoolShare_filter]
  poolId: String
  poolId_: Pool_filter
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_gt: String
  poolId_gte: String
  poolId_in: [String!]
  poolId_lt: String
  poolId_lte: String
  poolId_not: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  poolId_not_in: [String!]
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  userAddress: String
  userAddress_: User_filter
  userAddress_contains: String
  userAddress_contains_nocase: String
  userAddress_ends_with: String
  userAddress_ends_with_nocase: String
  userAddress_gt: String
  userAddress_gte: String
  userAddress_in: [String!]
  userAddress_lt: String
  userAddress_lte: String
  userAddress_not: String
  userAddress_not_contains: String
  userAddress_not_contains_nocase: String
  userAddress_not_ends_with: String
  userAddress_not_ends_with_nocase: String
  userAddress_not_in: [String!]
  userAddress_not_starts_with: String
  userAddress_not_starts_with_nocase: String
  userAddress_starts_with: String
  userAddress_starts_with_nocase: String
}

enum PoolShare_orderBy {
  balance
  id
  poolId
  poolId__address
  poolId__alpha
  poolId__amp
  poolId__baseToken
  poolId__beta
  poolId__c
  poolId__createTime
  poolId__dSq
  poolId__delta
  poolId__epsilon
  poolId__expiryTime
  poolId__factory
  poolId__holdersCount
  poolId__id
  poolId__isInRecoveryMode
  poolId__isPaused
  poolId__lambda
  poolId__lastPostJoinExitInvariant
  poolId__lowerTarget
  poolId__mainIndex
  poolId__managementFee
  poolId__name
  poolId__oracleEnabled
  poolId__owner
  poolId__poolType
  poolId__poolTypeVersion
  poolId__principalToken
  poolId__protocolAumFeeCache
  poolId__protocolId
  poolId__protocolSwapFeeCache
  poolId__protocolYieldFeeCache
  poolId__root3Alpha
  poolId__s
  poolId__sqrtAlpha
  poolId__sqrtBeta
  poolId__strategyType
  poolId__swapEnabled
  poolId__swapFee
  poolId__swapsCount
  poolId__symbol
  poolId__tauAlphaX
  poolId__tauAlphaY
  poolId__tauBetaX
  poolId__tauBetaY
  poolId__totalLiquidity
  poolId__totalShares
  poolId__totalSwapFee
  poolId__totalSwapVolume
  poolId__totalWeight
  poolId__tx
  poolId__u
  poolId__unitSeconds
  poolId__upperTarget
  poolId__v
  poolId__w
  poolId__wrappedIndex
  poolId__z
  userAddress
  userAddress__id
}

type PoolSnapshot {
  amounts: [BigDecimal!]!
  holdersCount: BigInt!
  id: ID!
  liquidity: BigDecimal!
  pool: Pool!
  swapFees: BigDecimal!
  swapVolume: BigDecimal!
  swapsCount: BigInt!
  timestamp: Int!
  totalShares: BigDecimal!
}

input PoolSnapshot_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amounts: [BigDecimal!]
  amounts_contains: [BigDecimal!]
  amounts_contains_nocase: [BigDecimal!]
  amounts_not: [BigDecimal!]
  amounts_not_contains: [BigDecimal!]
  amounts_not_contains_nocase: [BigDecimal!]
  and: [PoolSnapshot_filter]
  holdersCount: BigInt
  holdersCount_gt: BigInt
  holdersCount_gte: BigInt
  holdersCount_in: [BigInt!]
  holdersCount_lt: BigInt
  holdersCount_lte: BigInt
  holdersCount_not: BigInt
  holdersCount_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidity: BigDecimal
  liquidity_gt: BigDecimal
  liquidity_gte: BigDecimal
  liquidity_in: [BigDecimal!]
  liquidity_lt: BigDecimal
  liquidity_lte: BigDecimal
  liquidity_not: BigDecimal
  liquidity_not_in: [BigDecimal!]
  or: [PoolSnapshot_filter]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  swapFees: BigDecimal
  swapFees_gt: BigDecimal
  swapFees_gte: BigDecimal
  swapFees_in: [BigDecimal!]
  swapFees_lt: BigDecimal
  swapFees_lte: BigDecimal
  swapFees_not: BigDecimal
  swapFees_not_in: [BigDecimal!]
  swapVolume: BigDecimal
  swapVolume_gt: BigDecimal
  swapVolume_gte: BigDecimal
  swapVolume_in: [BigDecimal!]
  swapVolume_lt: BigDecimal
  swapVolume_lte: BigDecimal
  swapVolume_not: BigDecimal
  swapVolume_not_in: [BigDecimal!]
  swapsCount: BigInt
  swapsCount_gt: BigInt
  swapsCount_gte: BigInt
  swapsCount_in: [BigInt!]
  swapsCount_lt: BigInt
  swapsCount_lte: BigInt
  swapsCount_not: BigInt
  swapsCount_not_in: [BigInt!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  totalShares: BigDecimal
  totalShares_gt: BigDecimal
  totalShares_gte: BigDecimal
  totalShares_in: [BigDecimal!]
  totalShares_lt: BigDecimal
  totalShares_lte: BigDecimal
  totalShares_not: BigDecimal
  totalShares_not_in: [BigDecimal!]
}

enum PoolSnapshot_orderBy {
  amounts
  holdersCount
  id
  liquidity
  pool
  pool__address
  pool__alpha
  pool__amp
  pool__baseToken
  pool__beta
  pool__c
  pool__createTime
  pool__dSq
  pool__delta
  pool__epsilon
  pool__expiryTime
  pool__factory
  pool__holdersCount
  pool__id
  pool__isInRecoveryMode
  pool__isPaused
  pool__lambda
  pool__lastPostJoinExitInvariant
  pool__lowerTarget
  pool__mainIndex
  pool__managementFee
  pool__name
  pool__oracleEnabled
  pool__owner
  pool__poolType
  pool__poolTypeVersion
  pool__principalToken
  pool__protocolAumFeeCache
  pool__protocolId
  pool__protocolSwapFeeCache
  pool__protocolYieldFeeCache
  pool__root3Alpha
  pool__s
  pool__sqrtAlpha
  pool__sqrtBeta
  pool__strategyType
  pool__swapEnabled
  pool__swapFee
  pool__swapsCount
  pool__symbol
  pool__tauAlphaX
  pool__tauAlphaY
  pool__tauBetaX
  pool__tauBetaY
  pool__totalLiquidity
  pool__totalShares
  pool__totalSwapFee
  pool__totalSwapVolume
  pool__totalWeight
  pool__tx
  pool__u
  pool__unitSeconds
  pool__upperTarget
  pool__v
  pool__w
  pool__wrappedIndex
  pool__z
  swapFees
  swapVolume
  swapsCount
  timestamp
  totalShares
}

type PoolStakedTransaction implements PoolTransaction {
  amount: BigInt!
  hash: Bytes!
  id: ID!
  pool: Pool!
  poolAccount: PoolAccount!
  timestamp: Int!
}

input PoolStakedTransaction_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  hash: Bytes
  hash_contains: Bytes
  hash_in: [Bytes!]
  hash_not: Bytes
  hash_not_contains: Bytes
  hash_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  pool: String
  poolAccount: String
  poolAccount_: PoolAccount_filter
  poolAccount_contains: String
  poolAccount_contains_nocase: String
  poolAccount_ends_with: String
  poolAccount_ends_with_nocase: String
  poolAccount_gt: String
  poolAccount_gte: String
  poolAccount_in: [String!]
  poolAccount_lt: String
  poolAccount_lte: String
  poolAccount_not: String
  poolAccount_not_contains: String
  poolAccount_not_contains_nocase: String
  poolAccount_not_ends_with: String
  poolAccount_not_ends_with_nocase: String
  poolAccount_not_in: [String!]
  poolAccount_not_starts_with: String
  poolAccount_not_starts_with_nocase: String
  poolAccount_starts_with: String
  poolAccount_starts_with_nocase: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
}

enum PoolStakedTransaction_orderBy {
  amount
  hash
  id
  pool
  poolAccount
  timestamp
}

type PoolToken {
  address: String!
  assetManager: Bytes!
  balance: BigDecimal!
  cashBalance: BigDecimal!
  decimals: Int!
  id: ID!
  index: Int
  isExemptFromYieldProtocolFee: Boolean
  managedBalance: BigDecimal!
  managements(
    first: Int = 100
    orderBy: ManagementOperation_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: ManagementOperation_filter
  ): [ManagementOperation!]
  name: String!
  oldPriceRate: BigDecimal
  poolId: Pool
  priceRate: BigDecimal!
  symbol: String!
  token: Token!
  weight: BigDecimal
}

input PoolToken_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  address: String
  address_contains: String
  address_contains_nocase: String
  address_ends_with: String
  address_ends_with_nocase: String
  address_gt: String
  address_gte: String
  address_in: [String!]
  address_lt: String
  address_lte: String
  address_not: String
  address_not_contains: String
  address_not_contains_nocase: String
  address_not_ends_with: String
  address_not_ends_with_nocase: String
  address_not_in: [String!]
  address_not_starts_with: String
  address_not_starts_with_nocase: String
  address_starts_with: String
  address_starts_with_nocase: String
  and: [PoolToken_filter]
  assetManager: Bytes
  assetManager_contains: Bytes
  assetManager_gt: Bytes
  assetManager_gte: Bytes
  assetManager_in: [Bytes!]
  assetManager_lt: Bytes
  assetManager_lte: Bytes
  assetManager_not: Bytes
  assetManager_not_contains: Bytes
  assetManager_not_in: [Bytes!]
  balance: BigDecimal
  balance_gt: BigDecimal
  balance_gte: BigDecimal
  balance_in: [BigDecimal!]
  balance_lt: BigDecimal
  balance_lte: BigDecimal
  balance_not: BigDecimal
  balance_not_in: [BigDecimal!]
  cashBalance: BigDecimal
  cashBalance_gt: BigDecimal
  cashBalance_gte: BigDecimal
  cashBalance_in: [BigDecimal!]
  cashBalance_lt: BigDecimal
  cashBalance_lte: BigDecimal
  cashBalance_not: BigDecimal
  cashBalance_not_in: [BigDecimal!]
  decimals: Int
  decimals_gt: Int
  decimals_gte: Int
  decimals_in: [Int!]
  decimals_lt: Int
  decimals_lte: Int
  decimals_not: Int
  decimals_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  index: Int
  index_gt: Int
  index_gte: Int
  index_in: [Int!]
  index_lt: Int
  index_lte: Int
  index_not: Int
  index_not_in: [Int!]
  isExemptFromYieldProtocolFee: Boolean
  isExemptFromYieldProtocolFee_in: [Boolean!]
  isExemptFromYieldProtocolFee_not: Boolean
  isExemptFromYieldProtocolFee_not_in: [Boolean!]
  managedBalance: BigDecimal
  managedBalance_gt: BigDecimal
  managedBalance_gte: BigDecimal
  managedBalance_in: [BigDecimal!]
  managedBalance_lt: BigDecimal
  managedBalance_lte: BigDecimal
  managedBalance_not: BigDecimal
  managedBalance_not_in: [BigDecimal!]
  managements_: ManagementOperation_filter
  name: String
  name_contains: String
  name_contains_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  oldPriceRate: BigDecimal
  oldPriceRate_gt: BigDecimal
  oldPriceRate_gte: BigDecimal
  oldPriceRate_in: [BigDecimal!]
  oldPriceRate_lt: BigDecimal
  oldPriceRate_lte: BigDecimal
  oldPriceRate_not: BigDecimal
  oldPriceRate_not_in: [BigDecimal!]
  or: [PoolToken_filter]
  poolId: String
  poolId_: Pool_filter
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_gt: String
  poolId_gte: String
  poolId_in: [String!]
  poolId_lt: String
  poolId_lte: String
  poolId_not: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  poolId_not_in: [String!]
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  priceRate: BigDecimal
  priceRate_gt: BigDecimal
  priceRate_gte: BigDecimal
  priceRate_in: [BigDecimal!]
  priceRate_lt: BigDecimal
  priceRate_lte: BigDecimal
  priceRate_not: BigDecimal
  priceRate_not_in: [BigDecimal!]
  symbol: String
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  weight: BigDecimal
  weight_gt: BigDecimal
  weight_gte: BigDecimal
  weight_in: [BigDecimal!]
  weight_lt: BigDecimal
  weight_lte: BigDecimal
  weight_not: BigDecimal
  weight_not_in: [BigDecimal!]
}

enum PoolToken_orderBy {
  address
  assetManager
  balance
  cashBalance
  decimals
  id
  index
  isExemptFromYieldProtocolFee
  managedBalance
  managements
  name
  oldPriceRate
  poolId
  poolId__address
  poolId__alpha
  poolId__amp
  poolId__baseToken
  poolId__beta
  poolId__c
  poolId__createTime
  poolId__dSq
  poolId__delta
  poolId__epsilon
  poolId__expiryTime
  poolId__factory
  poolId__holdersCount
  poolId__id
  poolId__isInRecoveryMode
  poolId__isPaused
  poolId__lambda
  poolId__lastPostJoinExitInvariant
  poolId__lowerTarget
  poolId__mainIndex
  poolId__managementFee
  poolId__name
  poolId__oracleEnabled
  poolId__owner
  poolId__poolType
  poolId__poolTypeVersion
  poolId__principalToken
  poolId__protocolAumFeeCache
  poolId__protocolId
  poolId__protocolSwapFeeCache
  poolId__protocolYieldFeeCache
  poolId__root3Alpha
  poolId__s
  poolId__sqrtAlpha
  poolId__sqrtBeta
  poolId__strategyType
  poolId__swapEnabled
  poolId__swapFee
  poolId__swapsCount
  poolId__symbol
  poolId__tauAlphaX
  poolId__tauAlphaY
  poolId__tauBetaX
  poolId__tauBetaY
  poolId__totalLiquidity
  poolId__totalShares
  poolId__totalSwapFee
  poolId__totalSwapVolume
  poolId__totalWeight
  poolId__tx
  poolId__u
  poolId__unitSeconds
  poolId__upperTarget
  poolId__v
  poolId__w
  poolId__wrappedIndex
  poolId__z
  priceRate
  symbol
  token
  token__address
  token__decimals
  token__id
  token__latestFXPrice
  token__latestUSDPrice
  token__latestUSDPriceTimestamp
  token__name
  token__symbol
  token__totalBalanceNotional
  token__totalBalanceUSD
  token__totalSwapCount
  token__totalVolumeNotional
  token__totalVolumeUSD
  weight
}

interface PoolTransaction {
  hash: Bytes!
  id: ID!
  pool: Pool!
  poolAccount: PoolAccount!
  timestamp: Int!
}

input PoolTransaction_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  hash: Bytes
  hash_contains: Bytes
  hash_in: [Bytes!]
  hash_not: Bytes
  hash_not_contains: Bytes
  hash_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  pool: String
  poolAccount: String
  poolAccount_: PoolAccount_filter
  poolAccount_contains: String
  poolAccount_contains_nocase: String
  poolAccount_ends_with: String
  poolAccount_ends_with_nocase: String
  poolAccount_gt: String
  poolAccount_gte: String
  poolAccount_in: [String!]
  poolAccount_lt: String
  poolAccount_lte: String
  poolAccount_not: String
  poolAccount_not_contains: String
  poolAccount_not_contains_nocase: String
  poolAccount_not_ends_with: String
  poolAccount_not_ends_with_nocase: String
  poolAccount_not_in: [String!]
  poolAccount_not_starts_with: String
  poolAccount_not_starts_with_nocase: String
  poolAccount_starts_with: String
  poolAccount_starts_with_nocase: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
}

enum PoolTransaction_orderBy {
  hash
  id
  pool
  poolAccount
  timestamp
}

type PoolWithdrawnTransaction implements PoolTransaction {
  amount: BigInt!
  hash: Bytes!
  id: ID!
  pool: Pool!
  poolAccount: PoolAccount!
  timestamp: Int!
}

input PoolWithdrawnTransaction_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  hash: Bytes
  hash_contains: Bytes
  hash_in: [Bytes!]
  hash_not: Bytes
  hash_not_contains: Bytes
  hash_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  pool: String
  poolAccount: String
  poolAccount_: PoolAccount_filter
  poolAccount_contains: String
  poolAccount_contains_nocase: String
  poolAccount_ends_with: String
  poolAccount_ends_with_nocase: String
  poolAccount_gt: String
  poolAccount_gte: String
  poolAccount_in: [String!]
  poolAccount_lt: String
  poolAccount_lte: String
  poolAccount_not: String
  poolAccount_not_contains: String
  poolAccount_not_contains_nocase: String
  poolAccount_not_ends_with: String
  poolAccount_not_ends_with_nocase: String
  poolAccount_not_in: [String!]
  poolAccount_not_starts_with: String
  poolAccount_not_starts_with_nocase: String
  poolAccount_starts_with: String
  poolAccount_starts_with_nocase: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
}

enum PoolWithdrawnTransaction_orderBy {
  amount
  hash
  id
  pool
  poolAccount
  timestamp
}

input Pool_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  accounts_: PoolAccount_filter
  address: Bytes
  address_contains: Bytes
  address_gt: Bytes
  address_gte: Bytes
  address_in: [Bytes!]
  address_lt: Bytes
  address_lte: Bytes
  address_not: Bytes
  address_not_contains: Bytes
  address_not_in: [Bytes!]
  alpha: BigDecimal
  alpha_gt: BigDecimal
  alpha_gte: BigDecimal
  alpha_in: [BigDecimal!]
  alpha_lt: BigDecimal
  alpha_lte: BigDecimal
  alpha_not: BigDecimal
  alpha_not_in: [BigDecimal!]
  amp: BigInt
  amp_gt: BigInt
  amp_gte: BigInt
  amp_in: [BigInt!]
  amp_lt: BigInt
  amp_lte: BigInt
  amp_not: BigInt
  amp_not_in: [BigInt!]
  and: [Pool_filter]
  baseToken: Bytes
  baseToken_contains: Bytes
  baseToken_gt: Bytes
  baseToken_gte: Bytes
  baseToken_in: [Bytes!]
  baseToken_lt: Bytes
  baseToken_lte: Bytes
  baseToken_not: Bytes
  baseToken_not_contains: Bytes
  baseToken_not_in: [Bytes!]
  beta: BigDecimal
  beta_gt: BigDecimal
  beta_gte: BigDecimal
  beta_in: [BigDecimal!]
  beta_lt: BigDecimal
  beta_lte: BigDecimal
  beta_not: BigDecimal
  beta_not_in: [BigDecimal!]
  c: BigDecimal
  c_gt: BigDecimal
  c_gte: BigDecimal
  c_in: [BigDecimal!]
  c_lt: BigDecimal
  c_lte: BigDecimal
  c_not: BigDecimal
  c_not_in: [BigDecimal!]
  createTime: Int
  createTime_gt: Int
  createTime_gte: Int
  createTime_in: [Int!]
  createTime_lt: Int
  createTime_lte: Int
  createTime_not: Int
  createTime_not_in: [Int!]
  dSq: BigDecimal
  dSq_gt: BigDecimal
  dSq_gte: BigDecimal
  dSq_in: [BigDecimal!]
  dSq_lt: BigDecimal
  dSq_lte: BigDecimal
  dSq_not: BigDecimal
  dSq_not_in: [BigDecimal!]
  delta: BigDecimal
  delta_gt: BigDecimal
  delta_gte: BigDecimal
  delta_in: [BigDecimal!]
  delta_lt: BigDecimal
  delta_lte: BigDecimal
  delta_not: BigDecimal
  delta_not_in: [BigDecimal!]
  depositToken: String
  depositToken_: Token_filter
  depositToken_contains: String
  depositToken_contains_nocase: String
  depositToken_ends_with: String
  depositToken_ends_with_nocase: String
  depositToken_gt: String
  depositToken_gte: String
  depositToken_in: [String!]
  depositToken_lt: String
  depositToken_lte: String
  depositToken_not: String
  depositToken_not_contains: String
  depositToken_not_contains_nocase: String
  depositToken_not_ends_with: String
  depositToken_not_ends_with_nocase: String
  depositToken_not_in: [String!]
  depositToken_not_starts_with: String
  depositToken_not_starts_with_nocase: String
  depositToken_starts_with: String
  depositToken_starts_with_nocase: String
  epsilon: BigDecimal
  epsilon_gt: BigDecimal
  epsilon_gte: BigDecimal
  epsilon_in: [BigDecimal!]
  epsilon_lt: BigDecimal
  epsilon_lte: BigDecimal
  epsilon_not: BigDecimal
  epsilon_not_in: [BigDecimal!]
  expiryTime: BigInt
  expiryTime_gt: BigInt
  expiryTime_gte: BigInt
  expiryTime_in: [BigInt!]
  expiryTime_lt: BigInt
  expiryTime_lte: BigInt
  expiryTime_not: BigInt
  expiryTime_not_in: [BigInt!]
  factory: Bytes
  factoryPoolData: String
  factoryPoolData_: FactoryPoolData_filter
  factoryPoolData_contains: String
  factoryPoolData_contains_nocase: String
  factoryPoolData_ends_with: String
  factoryPoolData_ends_with_nocase: String
  factoryPoolData_gt: String
  factoryPoolData_gte: String
  factoryPoolData_in: [String!]
  factoryPoolData_lt: String
  factoryPoolData_lte: String
  factoryPoolData_not: String
  factoryPoolData_not_contains: String
  factoryPoolData_not_contains_nocase: String
  factoryPoolData_not_ends_with: String
  factoryPoolData_not_ends_with_nocase: String
  factoryPoolData_not_in: [String!]
  factoryPoolData_not_starts_with: String
  factoryPoolData_not_starts_with_nocase: String
  factoryPoolData_starts_with: String
  factoryPoolData_starts_with_nocase: String
  factory_contains: Bytes
  factory_gt: Bytes
  factory_gte: Bytes
  factory_in: [Bytes!]
  factory_lt: Bytes
  factory_lte: Bytes
  factory_not: Bytes
  factory_not_contains: Bytes
  factory_not_in: [Bytes!]
  gauge: String
  gauge_: Gauge_filter
  gauge_contains: String
  gauge_contains_nocase: String
  gauge_ends_with: String
  gauge_ends_with_nocase: String
  gauge_gt: String
  gauge_gte: String
  gauge_in: [String!]
  gauge_lt: String
  gauge_lte: String
  gauge_not: String
  gauge_not_contains: String
  gauge_not_contains_nocase: String
  gauge_not_ends_with: String
  gauge_not_ends_with_nocase: String
  gauge_not_in: [String!]
  gauge_not_starts_with: String
  gauge_not_starts_with_nocase: String
  gauge_starts_with: String
  gauge_starts_with_nocase: String
  historicalValues_: PoolHistoricalLiquidity_filter
  holdersCount: BigInt
  holdersCount_gt: BigInt
  holdersCount_gte: BigInt
  holdersCount_in: [BigInt!]
  holdersCount_lt: BigInt
  holdersCount_lte: BigInt
  holdersCount_not: BigInt
  holdersCount_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isFactoryPool: Boolean
  isFactoryPool_in: [Boolean!]
  isFactoryPool_not: Boolean
  isFactoryPool_not_in: [Boolean!]
  isInRecoveryMode: Boolean
  isInRecoveryMode_in: [Boolean!]
  isInRecoveryMode_not: Boolean
  isInRecoveryMode_not_in: [Boolean!]
  isPaused: Boolean
  isPaused_in: [Boolean!]
  isPaused_not: Boolean
  isPaused_not_in: [Boolean!]
  lambda: BigDecimal
  lambda_gt: BigDecimal
  lambda_gte: BigDecimal
  lambda_in: [BigDecimal!]
  lambda_lt: BigDecimal
  lambda_lte: BigDecimal
  lambda_not: BigDecimal
  lambda_not_in: [BigDecimal!]
  lastPostJoinExitInvariant: BigDecimal
  lastPostJoinExitInvariant_gt: BigDecimal
  lastPostJoinExitInvariant_gte: BigDecimal
  lastPostJoinExitInvariant_in: [BigDecimal!]
  lastPostJoinExitInvariant_lt: BigDecimal
  lastPostJoinExitInvariant_lte: BigDecimal
  lastPostJoinExitInvariant_not: BigDecimal
  lastPostJoinExitInvariant_not_in: [BigDecimal!]
  lowerTarget: BigDecimal
  lowerTarget_gt: BigDecimal
  lowerTarget_gte: BigDecimal
  lowerTarget_in: [BigDecimal!]
  lowerTarget_lt: BigDecimal
  lowerTarget_lte: BigDecimal
  lowerTarget_not: BigDecimal
  lowerTarget_not_in: [BigDecimal!]
  lpToken: String
  lpToken_: Token_filter
  lpToken_contains: String
  lpToken_contains_nocase: String
  lpToken_ends_with: String
  lpToken_ends_with_nocase: String
  lpToken_gt: String
  lpToken_gte: String
  lpToken_in: [String!]
  lpToken_lt: String
  lpToken_lte: String
  lpToken_not: String
  lpToken_not_contains: String
  lpToken_not_contains_nocase: String
  lpToken_not_ends_with: String
  lpToken_not_ends_with_nocase: String
  lpToken_not_in: [String!]
  lpToken_not_starts_with: String
  lpToken_not_starts_with_nocase: String
  lpToken_starts_with: String
  lpToken_starts_with_nocase: String
  mainIndex: Int
  mainIndex_gt: Int
  mainIndex_gte: Int
  mainIndex_in: [Int!]
  mainIndex_lt: Int
  mainIndex_lte: Int
  mainIndex_not: Int
  mainIndex_not_in: [Int!]
  managementFee: BigDecimal
  managementFee_gt: BigDecimal
  managementFee_gte: BigDecimal
  managementFee_in: [BigDecimal!]
  managementFee_lt: BigDecimal
  managementFee_lte: BigDecimal
  managementFee_not: BigDecimal
  managementFee_not_in: [BigDecimal!]
  name: String
  name_contains: String
  name_contains_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  or: [Pool_filter]
  oracleEnabled: Boolean
  oracleEnabled_in: [Boolean!]
  oracleEnabled_not: Boolean
  oracleEnabled_not_in: [Boolean!]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  poolType: String
  poolTypeVersion: Int
  poolTypeVersion_gt: Int
  poolTypeVersion_gte: Int
  poolTypeVersion_in: [Int!]
  poolTypeVersion_lt: Int
  poolTypeVersion_lte: Int
  poolTypeVersion_not: Int
  poolTypeVersion_not_in: [Int!]
  poolType_contains: String
  poolType_contains_nocase: String
  poolType_ends_with: String
  poolType_ends_with_nocase: String
  poolType_gt: String
  poolType_gte: String
  poolType_in: [String!]
  poolType_lt: String
  poolType_lte: String
  poolType_not: String
  poolType_not_contains: String
  poolType_not_contains_nocase: String
  poolType_not_ends_with: String
  poolType_not_ends_with_nocase: String
  poolType_not_in: [String!]
  poolType_not_starts_with: String
  poolType_not_starts_with_nocase: String
  poolType_starts_with: String
  poolType_starts_with_nocase: String
  priceRateProviders_: PriceRateProvider_filter
  principalToken: Bytes
  principalToken_contains: Bytes
  principalToken_gt: Bytes
  principalToken_gte: Bytes
  principalToken_in: [Bytes!]
  principalToken_lt: Bytes
  principalToken_lte: Bytes
  principalToken_not: Bytes
  principalToken_not_contains: Bytes
  principalToken_not_in: [Bytes!]
  protocolAumFeeCache: BigDecimal
  protocolAumFeeCache_gt: BigDecimal
  protocolAumFeeCache_gte: BigDecimal
  protocolAumFeeCache_in: [BigDecimal!]
  protocolAumFeeCache_lt: BigDecimal
  protocolAumFeeCache_lte: BigDecimal
  protocolAumFeeCache_not: BigDecimal
  protocolAumFeeCache_not_in: [BigDecimal!]
  protocolId: Int
  protocolIdData: String
  protocolIdData_: ProtocolIdData_filter
  protocolIdData_contains: String
  protocolIdData_contains_nocase: String
  protocolIdData_ends_with: String
  protocolIdData_ends_with_nocase: String
  protocolIdData_gt: String
  protocolIdData_gte: String
  protocolIdData_in: [String!]
  protocolIdData_lt: String
  protocolIdData_lte: String
  protocolIdData_not: String
  protocolIdData_not_contains: String
  protocolIdData_not_contains_nocase: String
  protocolIdData_not_ends_with: String
  protocolIdData_not_ends_with_nocase: String
  protocolIdData_not_in: [String!]
  protocolIdData_not_starts_with: String
  protocolIdData_not_starts_with_nocase: String
  protocolIdData_starts_with: String
  protocolIdData_starts_with_nocase: String
  protocolId_gt: Int
  protocolId_gte: Int
  protocolId_in: [Int!]
  protocolId_lt: Int
  protocolId_lte: Int
  protocolId_not: Int
  protocolId_not_in: [Int!]
  protocolSwapFeeCache: BigDecimal
  protocolSwapFeeCache_gt: BigDecimal
  protocolSwapFeeCache_gte: BigDecimal
  protocolSwapFeeCache_in: [BigDecimal!]
  protocolSwapFeeCache_lt: BigDecimal
  protocolSwapFeeCache_lte: BigDecimal
  protocolSwapFeeCache_not: BigDecimal
  protocolSwapFeeCache_not_in: [BigDecimal!]
  protocolYieldFeeCache: BigDecimal
  protocolYieldFeeCache_gt: BigDecimal
  protocolYieldFeeCache_gte: BigDecimal
  protocolYieldFeeCache_in: [BigDecimal!]
  protocolYieldFeeCache_lt: BigDecimal
  protocolYieldFeeCache_lte: BigDecimal
  protocolYieldFeeCache_not: BigDecimal
  protocolYieldFeeCache_not_in: [BigDecimal!]
  rewardData_: PoolRewardData_filter
  rewardPaidTransactions_: PoolRewardPaidTransaction_filter
  rewardPool: Bytes
  rewardPool_contains: Bytes
  rewardPool_in: [Bytes!]
  rewardPool_not: Bytes
  rewardPool_not_contains: Bytes
  rewardPool_not_in: [Bytes!]
  rewardToken: String
  rewardToken_: Token_filter
  rewardToken_contains: String
  rewardToken_contains_nocase: String
  rewardToken_ends_with: String
  rewardToken_ends_with_nocase: String
  rewardToken_gt: String
  rewardToken_gte: String
  rewardToken_in: [String!]
  rewardToken_lt: String
  rewardToken_lte: String
  rewardToken_not: String
  rewardToken_not_contains: String
  rewardToken_not_contains_nocase: String
  rewardToken_not_ends_with: String
  rewardToken_not_ends_with_nocase: String
  rewardToken_not_in: [String!]
  rewardToken_not_starts_with: String
  rewardToken_not_starts_with_nocase: String
  rewardToken_starts_with: String
  rewardToken_starts_with_nocase: String
  root3Alpha: BigDecimal
  root3Alpha_gt: BigDecimal
  root3Alpha_gte: BigDecimal
  root3Alpha_in: [BigDecimal!]
  root3Alpha_lt: BigDecimal
  root3Alpha_lte: BigDecimal
  root3Alpha_not: BigDecimal
  root3Alpha_not_in: [BigDecimal!]
  s: BigDecimal
  s_gt: BigDecimal
  s_gte: BigDecimal
  s_in: [BigDecimal!]
  s_lt: BigDecimal
  s_lte: BigDecimal
  s_not: BigDecimal
  s_not_in: [BigDecimal!]
  shares_: PoolShare_filter
  snapshots_: PoolSnapshot_filter
  sqrtAlpha: BigDecimal
  sqrtAlpha_gt: BigDecimal
  sqrtAlpha_gte: BigDecimal
  sqrtAlpha_in: [BigDecimal!]
  sqrtAlpha_lt: BigDecimal
  sqrtAlpha_lte: BigDecimal
  sqrtAlpha_not: BigDecimal
  sqrtAlpha_not_in: [BigDecimal!]
  sqrtBeta: BigDecimal
  sqrtBeta_gt: BigDecimal
  sqrtBeta_gte: BigDecimal
  sqrtBeta_in: [BigDecimal!]
  sqrtBeta_lt: BigDecimal
  sqrtBeta_lte: BigDecimal
  sqrtBeta_not: BigDecimal
  sqrtBeta_not_in: [BigDecimal!]
  stakedTransactions_: PoolStakedTransaction_filter
  startTime: Int
  startTime_gt: Int
  startTime_gte: Int
  startTime_in: [Int!]
  startTime_lt: Int
  startTime_lte: Int
  startTime_not: Int
  startTime_not_in: [Int!]
  strategyType: Int
  strategyType_gt: Int
  strategyType_gte: Int
  strategyType_in: [Int!]
  strategyType_lt: Int
  strategyType_lte: Int
  strategyType_not: Int
  strategyType_not_in: [Int!]
  swapEnabled: Boolean
  swapEnabled_in: [Boolean!]
  swapEnabled_not: Boolean
  swapEnabled_not_in: [Boolean!]
  swapFee: BigDecimal
  swapFee_gt: BigDecimal
  swapFee_gte: BigDecimal
  swapFee_in: [BigDecimal!]
  swapFee_lt: BigDecimal
  swapFee_lte: BigDecimal
  swapFee_not: BigDecimal
  swapFee_not_in: [BigDecimal!]
  swapsCount: BigInt
  swapsCount_gt: BigInt
  swapsCount_gte: BigInt
  swapsCount_in: [BigInt!]
  swapsCount_lt: BigInt
  swapsCount_lte: BigInt
  swapsCount_not: BigInt
  swapsCount_not_in: [BigInt!]
  swaps_: Swap_filter
  symbol: String
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  tauAlphaX: BigDecimal
  tauAlphaX_gt: BigDecimal
  tauAlphaX_gte: BigDecimal
  tauAlphaX_in: [BigDecimal!]
  tauAlphaX_lt: BigDecimal
  tauAlphaX_lte: BigDecimal
  tauAlphaX_not: BigDecimal
  tauAlphaX_not_in: [BigDecimal!]
  tauAlphaY: BigDecimal
  tauAlphaY_gt: BigDecimal
  tauAlphaY_gte: BigDecimal
  tauAlphaY_in: [BigDecimal!]
  tauAlphaY_lt: BigDecimal
  tauAlphaY_lte: BigDecimal
  tauAlphaY_not: BigDecimal
  tauAlphaY_not_in: [BigDecimal!]
  tauBetaX: BigDecimal
  tauBetaX_gt: BigDecimal
  tauBetaX_gte: BigDecimal
  tauBetaX_in: [BigDecimal!]
  tauBetaX_lt: BigDecimal
  tauBetaX_lte: BigDecimal
  tauBetaX_not: BigDecimal
  tauBetaX_not_in: [BigDecimal!]
  tauBetaY: BigDecimal
  tauBetaY_gt: BigDecimal
  tauBetaY_gte: BigDecimal
  tauBetaY_in: [BigDecimal!]
  tauBetaY_lt: BigDecimal
  tauBetaY_lte: BigDecimal
  tauBetaY_not: BigDecimal
  tauBetaY_not_in: [BigDecimal!]
  tokensList: [Bytes!]
  tokensList_contains: [Bytes!]
  tokensList_contains_nocase: [Bytes!]
  tokensList_not: [Bytes!]
  tokensList_not_contains: [Bytes!]
  tokensList_not_contains_nocase: [Bytes!]
  tokens_: PoolToken_filter
  totalLiquidity: BigDecimal
  totalLiquidity_gt: BigDecimal
  totalLiquidity_gte: BigDecimal
  totalLiquidity_in: [BigDecimal!]
  totalLiquidity_lt: BigDecimal
  totalLiquidity_lte: BigDecimal
  totalLiquidity_not: BigDecimal
  totalLiquidity_not_in: [BigDecimal!]
  totalShares: BigDecimal
  totalShares_gt: BigDecimal
  totalShares_gte: BigDecimal
  totalShares_in: [BigDecimal!]
  totalShares_lt: BigDecimal
  totalShares_lte: BigDecimal
  totalShares_not: BigDecimal
  totalShares_not_in: [BigDecimal!]
  totalStaked: BigInt
  totalStaked_gt: BigInt
  totalStaked_gte: BigInt
  totalStaked_in: [BigInt!]
  totalStaked_lt: BigInt
  totalStaked_lte: BigInt
  totalStaked_not: BigInt
  totalStaked_not_in: [BigInt!]
  totalSupply: BigInt
  totalSupply_gt: BigInt
  totalSupply_gte: BigInt
  totalSupply_in: [BigInt!]
  totalSupply_lt: BigInt
  totalSupply_lte: BigInt
  totalSupply_not: BigInt
  totalSupply_not_in: [BigInt!]
  totalSwapFee: BigDecimal
  totalSwapFee_gt: BigDecimal
  totalSwapFee_gte: BigDecimal
  totalSwapFee_in: [BigDecimal!]
  totalSwapFee_lt: BigDecimal
  totalSwapFee_lte: BigDecimal
  totalSwapFee_not: BigDecimal
  totalSwapFee_not_in: [BigDecimal!]
  totalSwapVolume: BigDecimal
  totalSwapVolume_gt: BigDecimal
  totalSwapVolume_gte: BigDecimal
  totalSwapVolume_in: [BigDecimal!]
  totalSwapVolume_lt: BigDecimal
  totalSwapVolume_lte: BigDecimal
  totalSwapVolume_not: BigDecimal
  totalSwapVolume_not_in: [BigDecimal!]
  totalWeight: BigDecimal
  totalWeight_gt: BigDecimal
  totalWeight_gte: BigDecimal
  totalWeight_in: [BigDecimal!]
  totalWeight_lt: BigDecimal
  totalWeight_lte: BigDecimal
  totalWeight_not: BigDecimal
  totalWeight_not_in: [BigDecimal!]
  tx: Bytes
  tx_contains: Bytes
  tx_gt: Bytes
  tx_gte: Bytes
  tx_in: [Bytes!]
  tx_lt: Bytes
  tx_lte: Bytes
  tx_not: Bytes
  tx_not_contains: Bytes
  tx_not_in: [Bytes!]
  u: BigDecimal
  u_gt: BigDecimal
  u_gte: BigDecimal
  u_in: [BigDecimal!]
  u_lt: BigDecimal
  u_lte: BigDecimal
  u_not: BigDecimal
  u_not_in: [BigDecimal!]
  unitSeconds: BigInt
  unitSeconds_gt: BigInt
  unitSeconds_gte: BigInt
  unitSeconds_in: [BigInt!]
  unitSeconds_lt: BigInt
  unitSeconds_lte: BigInt
  unitSeconds_not: BigInt
  unitSeconds_not_in: [BigInt!]
  upperTarget: BigDecimal
  upperTarget_gt: BigDecimal
  upperTarget_gte: BigDecimal
  upperTarget_in: [BigDecimal!]
  upperTarget_lt: BigDecimal
  upperTarget_lte: BigDecimal
  upperTarget_not: BigDecimal
  upperTarget_not_in: [BigDecimal!]
  v: BigDecimal
  v_gt: BigDecimal
  v_gte: BigDecimal
  v_in: [BigDecimal!]
  v_lt: BigDecimal
  v_lte: BigDecimal
  v_not: BigDecimal
  v_not_in: [BigDecimal!]
  vaultID: String
  vaultID_: Balancer_filter
  vaultID_contains: String
  vaultID_contains_nocase: String
  vaultID_ends_with: String
  vaultID_ends_with_nocase: String
  vaultID_gt: String
  vaultID_gte: String
  vaultID_in: [String!]
  vaultID_lt: String
  vaultID_lte: String
  vaultID_not: String
  vaultID_not_contains: String
  vaultID_not_contains_nocase: String
  vaultID_not_ends_with: String
  vaultID_not_ends_with_nocase: String
  vaultID_not_in: [String!]
  vaultID_not_starts_with: String
  vaultID_not_starts_with_nocase: String
  vaultID_starts_with: String
  vaultID_starts_with_nocase: String
  w: BigDecimal
  w_gt: BigDecimal
  w_gte: BigDecimal
  w_in: [BigDecimal!]
  w_lt: BigDecimal
  w_lte: BigDecimal
  w_not: BigDecimal
  w_not_in: [BigDecimal!]
  weightUpdates_: GradualWeightUpdate_filter
  withdrawnTransactions_: PoolWithdrawnTransaction_filter
  wrappedIndex: Int
  wrappedIndex_gt: Int
  wrappedIndex_gte: Int
  wrappedIndex_in: [Int!]
  wrappedIndex_lt: Int
  wrappedIndex_lte: Int
  wrappedIndex_not: Int
  wrappedIndex_not_in: [Int!]
  z: BigDecimal
  z_gt: BigDecimal
  z_gte: BigDecimal
  z_in: [BigDecimal!]
  z_lt: BigDecimal
  z_lte: BigDecimal
  z_not: BigDecimal
  z_not_in: [BigDecimal!]
}

enum Pool_orderBy {
  accounts
  address
  alpha
  amp
  baseToken
  beta
  c
  createTime
  dSq
  delta
  depositToken
  epsilon
  expiryTime
  factory
  factoryPoolData
  gauge
  historicalValues
  holdersCount
  id
  isFactoryPool
  isInRecoveryMode
  isPaused
  lambda
  lastPostJoinExitInvariant
  lowerTarget
  lpToken
  mainIndex
  managementFee
  name
  oracleEnabled
  owner
  poolType
  poolTypeVersion
  priceRateProviders
  principalToken
  protocolAumFeeCache
  protocolId
  protocolIdData
  protocolIdData__id
  protocolIdData__name
  protocolSwapFeeCache
  protocolYieldFeeCache
  rewardData
  rewardPaidTransactions
  rewardPool
  rewardToken
  root3Alpha
  s
  shares
  snapshots
  sqrtAlpha
  sqrtBeta
  stakedTransactions
  startTime
  strategyType
  swapEnabled
  swapFee
  swaps
  swapsCount
  symbol
  tauAlphaX
  tauAlphaY
  tauBetaX
  tauBetaY
  tokens
  tokensList
  totalLiquidity
  totalShares
  totalStaked
  totalSupply
  totalSwapFee
  totalSwapVolume
  totalWeight
  tx
  u
  unitSeconds
  upperTarget
  v
  vaultID
  vaultID__id
  vaultID__poolCount
  vaultID__totalLiquidity
  vaultID__totalSwapCount
  vaultID__totalSwapFee
  vaultID__totalSwapVolume
  w
  weightUpdates
  withdrawnTransactions
  wrappedIndex
  z
}

type PriceRateProvider {
  address: Bytes!
  cacheDuration: Int
  cacheExpiry: Int
  id: ID!
  lastCached: Int
  poolId: Pool!
  rate: BigDecimal
  token: PoolToken!
}

input PriceRateProvider_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  address: Bytes
  address_contains: Bytes
  address_gt: Bytes
  address_gte: Bytes
  address_in: [Bytes!]
  address_lt: Bytes
  address_lte: Bytes
  address_not: Bytes
  address_not_contains: Bytes
  address_not_in: [Bytes!]
  and: [PriceRateProvider_filter]
  cacheDuration: Int
  cacheDuration_gt: Int
  cacheDuration_gte: Int
  cacheDuration_in: [Int!]
  cacheDuration_lt: Int
  cacheDuration_lte: Int
  cacheDuration_not: Int
  cacheDuration_not_in: [Int!]
  cacheExpiry: Int
  cacheExpiry_gt: Int
  cacheExpiry_gte: Int
  cacheExpiry_in: [Int!]
  cacheExpiry_lt: Int
  cacheExpiry_lte: Int
  cacheExpiry_not: Int
  cacheExpiry_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lastCached: Int
  lastCached_gt: Int
  lastCached_gte: Int
  lastCached_in: [Int!]
  lastCached_lt: Int
  lastCached_lte: Int
  lastCached_not: Int
  lastCached_not_in: [Int!]
  or: [PriceRateProvider_filter]
  poolId: String
  poolId_: Pool_filter
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_gt: String
  poolId_gte: String
  poolId_in: [String!]
  poolId_lt: String
  poolId_lte: String
  poolId_not: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  poolId_not_in: [String!]
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  rate: BigDecimal
  rate_gt: BigDecimal
  rate_gte: BigDecimal
  rate_in: [BigDecimal!]
  rate_lt: BigDecimal
  rate_lte: BigDecimal
  rate_not: BigDecimal
  rate_not_in: [BigDecimal!]
  token: String
  token_: PoolToken_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
}

enum PriceRateProvider_orderBy {
  address
  cacheDuration
  cacheExpiry
  id
  lastCached
  poolId
  poolId__address
  poolId__alpha
  poolId__amp
  poolId__baseToken
  poolId__beta
  poolId__c
  poolId__createTime
  poolId__dSq
  poolId__delta
  poolId__epsilon
  poolId__expiryTime
  poolId__factory
  poolId__holdersCount
  poolId__id
  poolId__isInRecoveryMode
  poolId__isPaused
  poolId__lambda
  poolId__lastPostJoinExitInvariant
  poolId__lowerTarget
  poolId__mainIndex
  poolId__managementFee
  poolId__name
  poolId__oracleEnabled
  poolId__owner
  poolId__poolType
  poolId__poolTypeVersion
  poolId__principalToken
  poolId__protocolAumFeeCache
  poolId__protocolId
  poolId__protocolSwapFeeCache
  poolId__protocolYieldFeeCache
  poolId__root3Alpha
  poolId__s
  poolId__sqrtAlpha
  poolId__sqrtBeta
  poolId__strategyType
  poolId__swapEnabled
  poolId__swapFee
  poolId__swapsCount
  poolId__symbol
  poolId__tauAlphaX
  poolId__tauAlphaY
  poolId__tauBetaX
  poolId__tauBetaY
  poolId__totalLiquidity
  poolId__totalShares
  poolId__totalSwapFee
  poolId__totalSwapVolume
  poolId__totalWeight
  poolId__tx
  poolId__u
  poolId__unitSeconds
  poolId__upperTarget
  poolId__v
  poolId__w
  poolId__wrappedIndex
  poolId__z
  rate
  token
  token__address
  token__assetManager
  token__balance
  token__cashBalance
  token__decimals
  token__id
  token__index
  token__isExemptFromYieldProtocolFee
  token__managedBalance
  token__name
  token__oldPriceRate
  token__priceRate
  token__symbol
  token__weight
}

type ProtocolIdData {
  id: ID!
  name: String!
}

input ProtocolIdData_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [ProtocolIdData_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  name: String
  name_contains: String
  name_contains_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  or: [ProtocolIdData_filter]
}

enum ProtocolIdData_orderBy {
  id
  name
}

type Query {
  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
  account(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Account_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Account_filter
  ): [Account!]!
  ampUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AmpUpdate
  ampUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AmpUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AmpUpdate_filter
  ): [AmpUpdate!]!
  auraBalMintTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuraBalMintTransaction
  auraBalMintTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AuraBalMintTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AuraBalMintTransaction_filter
  ): [AuraBalMintTransaction!]!
  auraLocker(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuraLocker
  auraLockerAccount(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuraLockerAccount
  auraLockerAccounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AuraLockerAccount_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AuraLockerAccount_filter
  ): [AuraLockerAccount!]!
  auraLockerRewardData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuraLockerRewardData
  auraLockerRewardDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AuraLockerRewardData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AuraLockerRewardData_filter
  ): [AuraLockerRewardData!]!
  auraLockerUserData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuraLockerUserData
  auraLockerUserDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AuraLockerUserData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AuraLockerUserData_filter
  ): [AuraLockerUserData!]!
  auraLockerUserLock(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuraLockerUserLock
  auraLockerUserLocks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AuraLockerUserLock_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AuraLockerUserLock_filter
  ): [AuraLockerUserLock!]!
  auraLockers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AuraLocker_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AuraLocker_filter
  ): [AuraLocker!]!
  balancer(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Balancer
  balancerSnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BalancerSnapshot
  balancerSnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BalancerSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BalancerSnapshot_filter
  ): [BalancerSnapshot!]!
  balancers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Balancer_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Balancer_filter
  ): [Balancer!]!
  block(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Block
  blocks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Block_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Block_filter
  ): [Block!]!
  factoryPoolData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FactoryPoolData
  factoryPoolDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FactoryPoolData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FactoryPoolData_filter
  ): [FactoryPoolData!]!
  gauge(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Gauge
  gauges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Gauge_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Gauge_filter
  ): [Gauge!]!
  global(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Global
  globals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Global_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Global_filter
  ): [Global!]!
  gradualWeightUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GradualWeightUpdate
  gradualWeightUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: GradualWeightUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: GradualWeightUpdate_filter
  ): [GradualWeightUpdate!]!
  joinExit(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): JoinExit
  joinExits(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: JoinExit_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: JoinExit_filter
  ): [JoinExit!]!
  latestPrice(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LatestPrice
  latestPrices(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LatestPrice_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LatestPrice_filter
  ): [LatestPrice!]!
  lockerDelegateChangedTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LockerDelegateChangedTransaction
  lockerDelegateChangedTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LockerDelegateChangedTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LockerDelegateChangedTransaction_filter
  ): [LockerDelegateChangedTransaction!]!
  lockerKickRewardTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LockerKickRewardTransaction
  lockerKickRewardTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LockerKickRewardTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LockerKickRewardTransaction_filter
  ): [LockerKickRewardTransaction!]!
  lockerRewardPaidTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LockerRewardPaidTransaction
  lockerRewardPaidTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LockerRewardPaidTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LockerRewardPaidTransaction_filter
  ): [LockerRewardPaidTransaction!]!
  lockerStakedTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LockerStakedTransaction
  lockerStakedTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LockerStakedTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LockerStakedTransaction_filter
  ): [LockerStakedTransaction!]!
  lockerTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LockerTransaction
  lockerTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LockerTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LockerTransaction_filter
  ): [LockerTransaction!]!
  lockerWithdrawnTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LockerWithdrawnTransaction
  lockerWithdrawnTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LockerWithdrawnTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LockerWithdrawnTransaction_filter
  ): [LockerWithdrawnTransaction!]!
  managementOperation(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ManagementOperation
  managementOperations(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ManagementOperation_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ManagementOperation_filter
  ): [ManagementOperation!]!
  masterChef(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MasterChef
  masterChefPoolInfo(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MasterChefPoolInfo
  masterChefPoolInfos(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MasterChefPoolInfo_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MasterChefPoolInfo_filter
  ): [MasterChefPoolInfo!]!
  masterChefUserInfo(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MasterChefUserInfo
  masterChefUserInfos(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MasterChefUserInfo_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MasterChefUserInfo_filter
  ): [MasterChefUserInfo!]!
  masterChefs(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MasterChef_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MasterChef_filter
  ): [MasterChef!]!
  merkleDrop(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MerkleDrop
  merkleDropClaim(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MerkleDropClaim
  merkleDropClaims(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MerkleDropClaim_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MerkleDropClaim_filter
  ): [MerkleDropClaim!]!
  merkleDrops(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MerkleDrop_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MerkleDrop_filter
  ): [MerkleDrop!]!
  pool(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pool
  poolAccount(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolAccount
  poolAccountRewards(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolAccountRewards_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolAccountRewards_filter
  ): [PoolAccountRewards!]!
  poolAccounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolAccount_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolAccount_filter
  ): [PoolAccount!]!
  poolContract(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolContract
  poolContracts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolContract_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolContract_filter
  ): [PoolContract!]!
  poolHistoricalLiquidities(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolHistoricalLiquidity_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolHistoricalLiquidity_filter
  ): [PoolHistoricalLiquidity!]!
  poolHistoricalLiquidity(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolHistoricalLiquidity
  poolRewardData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolRewardData
  poolRewardDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolRewardData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolRewardData_filter
  ): [PoolRewardData!]!
  poolRewardPaidTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolRewardPaidTransaction
  poolRewardPaidTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolRewardPaidTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolRewardPaidTransaction_filter
  ): [PoolRewardPaidTransaction!]!
  poolShare(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolShare
  poolShares(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolShare_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolShare_filter
  ): [PoolShare!]!
  poolSnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolSnapshot
  poolSnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolSnapshot_filter
  ): [PoolSnapshot!]!
  poolStakedTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolStakedTransaction
  poolStakedTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolStakedTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolStakedTransaction_filter
  ): [PoolStakedTransaction!]!
  poolToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolToken
  poolTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolToken_filter
  ): [PoolToken!]!
  poolTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolTransaction
  poolTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolTransaction_filter
  ): [PoolTransaction!]!
  poolWithdrawnTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolWithdrawnTransaction
  poolWithdrawnTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolWithdrawnTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolWithdrawnTransaction_filter
  ): [PoolWithdrawnTransaction!]!
  pools(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Pool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Pool_filter
  ): [Pool!]!
  priceRateProvider(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PriceRateProvider
  priceRateProviders(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PriceRateProvider_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PriceRateProvider_filter
  ): [PriceRateProvider!]!
  protocolIdData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ProtocolIdData
  protocolIdDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ProtocolIdData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ProtocolIdData_filter
  ): [ProtocolIdData!]!
  rewardData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardData
  rewardDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RewardData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RewardData_filter
  ): [RewardData!]!
  swap(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swapFeeUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SwapFeeUpdate
  swapFeeUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SwapFeeUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SwapFeeUpdate_filter
  ): [SwapFeeUpdate!]!
  swaps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Swap_filter
  ): [Swap!]!
  token(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokenPrice(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenPrice
  tokenPrices(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenPrice_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenPrice_filter
  ): [TokenPrice!]!
  tokenSnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenSnapshot
  tokenSnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenSnapshot_filter
  ): [TokenSnapshot!]!
  tokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Token_filter
  ): [Token!]!
  tradePair(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TradePair
  tradePairSnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TradePairSnapshot
  tradePairSnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TradePairSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TradePairSnapshot_filter
  ): [TradePairSnapshot!]!
  tradePairs(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TradePair_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TradePair_filter
  ): [TradePair!]!
  user(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  userInternalBalance(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserInternalBalance
  userInternalBalances(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserInternalBalance_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserInternalBalance_filter
  ): [UserInternalBalance!]!
  users(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: User_filter
  ): [User!]!
  vault(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Vault
  vaultAccount(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VaultAccount
  vaultAccountReward(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VaultAccountReward
  vaultAccountRewards(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VaultAccountReward_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VaultAccountReward_filter
  ): [VaultAccountReward!]!
  vaultAccounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VaultAccount_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VaultAccount_filter
  ): [VaultAccount!]!
  vaultDepositTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VaultDepositTransaction
  vaultDepositTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VaultDepositTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VaultDepositTransaction_filter
  ): [VaultDepositTransaction!]!
  vaultHarvestTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VaultHarvestTransaction
  vaultHarvestTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VaultHarvestTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VaultHarvestTransaction_filter
  ): [VaultHarvestTransaction!]!
  vaultRewardData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VaultRewardData
  vaultRewardDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VaultRewardData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VaultRewardData_filter
  ): [VaultRewardData!]!
  vaultRewardPaidTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VaultRewardPaidTransaction
  vaultRewardPaidTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VaultRewardPaidTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VaultRewardPaidTransaction_filter
  ): [VaultRewardPaidTransaction!]!
  vaultTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VaultTransaction
  vaultTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VaultTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VaultTransaction_filter
  ): [VaultTransaction!]!
  vaultWithdrawTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VaultWithdrawTransaction
  vaultWithdrawTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VaultWithdrawTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VaultWithdrawTransaction_filter
  ): [VaultWithdrawTransaction!]!
  vaults(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Vault_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Vault_filter
  ): [Vault!]!
}

interface RewardData {
  """
  Last time any user took action
  """
  lastUpdateTime: Int!

  """
  Timestamp for current period finish
  """
  periodFinish: Int!

  """
  Ever increasing rewardPerToken rate, based on % of total supply
  """
  rewardPerTokenStored: BigInt!

  """
  RewardRate for the rest of the period
  """
  rewardRate: BigInt!
  token: Token!
}

input RewardData_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  lastUpdateTime: Int
  lastUpdateTime_gt: Int
  lastUpdateTime_gte: Int
  lastUpdateTime_in: [Int!]
  lastUpdateTime_lt: Int
  lastUpdateTime_lte: Int
  lastUpdateTime_not: Int
  lastUpdateTime_not_in: [Int!]
  periodFinish: Int
  periodFinish_gt: Int
  periodFinish_gte: Int
  periodFinish_in: [Int!]
  periodFinish_lt: Int
  periodFinish_lte: Int
  periodFinish_not: Int
  periodFinish_not_in: [Int!]
  rewardPerTokenStored: BigInt
  rewardPerTokenStored_gt: BigInt
  rewardPerTokenStored_gte: BigInt
  rewardPerTokenStored_in: [BigInt!]
  rewardPerTokenStored_lt: BigInt
  rewardPerTokenStored_lte: BigInt
  rewardPerTokenStored_not: BigInt
  rewardPerTokenStored_not_in: [BigInt!]
  rewardRate: BigInt
  rewardRate_gt: BigInt
  rewardRate_gte: BigInt
  rewardRate_in: [BigInt!]
  rewardRate_lt: BigInt
  rewardRate_lte: BigInt
  rewardRate_not: BigInt
  rewardRate_not_in: [BigInt!]
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
}

enum RewardData_orderBy {
  lastUpdateTime
  periodFinish
  rewardPerTokenStored
  rewardRate
  token
}

type Subscription {
  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
  account(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Account_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Account_filter
  ): [Account!]!
  ampUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AmpUpdate
  ampUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AmpUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AmpUpdate_filter
  ): [AmpUpdate!]!
  auraBalMintTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuraBalMintTransaction
  auraBalMintTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AuraBalMintTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AuraBalMintTransaction_filter
  ): [AuraBalMintTransaction!]!
  auraLocker(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuraLocker
  auraLockerAccount(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuraLockerAccount
  auraLockerAccounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AuraLockerAccount_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AuraLockerAccount_filter
  ): [AuraLockerAccount!]!
  auraLockerRewardData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuraLockerRewardData
  auraLockerRewardDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AuraLockerRewardData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AuraLockerRewardData_filter
  ): [AuraLockerRewardData!]!
  auraLockerUserData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuraLockerUserData
  auraLockerUserDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AuraLockerUserData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AuraLockerUserData_filter
  ): [AuraLockerUserData!]!
  auraLockerUserLock(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuraLockerUserLock
  auraLockerUserLocks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AuraLockerUserLock_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AuraLockerUserLock_filter
  ): [AuraLockerUserLock!]!
  auraLockers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AuraLocker_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AuraLocker_filter
  ): [AuraLocker!]!
  balancer(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Balancer
  balancerSnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BalancerSnapshot
  balancerSnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BalancerSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BalancerSnapshot_filter
  ): [BalancerSnapshot!]!
  balancers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Balancer_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Balancer_filter
  ): [Balancer!]!
  block(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Block
  blocks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Block_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Block_filter
  ): [Block!]!
  factoryPoolData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FactoryPoolData
  factoryPoolDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FactoryPoolData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FactoryPoolData_filter
  ): [FactoryPoolData!]!
  gauge(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Gauge
  gauges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Gauge_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Gauge_filter
  ): [Gauge!]!
  global(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Global
  globals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Global_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Global_filter
  ): [Global!]!
  gradualWeightUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GradualWeightUpdate
  gradualWeightUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: GradualWeightUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: GradualWeightUpdate_filter
  ): [GradualWeightUpdate!]!
  joinExit(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): JoinExit
  joinExits(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: JoinExit_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: JoinExit_filter
  ): [JoinExit!]!
  latestPrice(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LatestPrice
  latestPrices(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LatestPrice_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LatestPrice_filter
  ): [LatestPrice!]!
  lockerDelegateChangedTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LockerDelegateChangedTransaction
  lockerDelegateChangedTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LockerDelegateChangedTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LockerDelegateChangedTransaction_filter
  ): [LockerDelegateChangedTransaction!]!
  lockerKickRewardTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LockerKickRewardTransaction
  lockerKickRewardTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LockerKickRewardTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LockerKickRewardTransaction_filter
  ): [LockerKickRewardTransaction!]!
  lockerRewardPaidTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LockerRewardPaidTransaction
  lockerRewardPaidTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LockerRewardPaidTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LockerRewardPaidTransaction_filter
  ): [LockerRewardPaidTransaction!]!
  lockerStakedTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LockerStakedTransaction
  lockerStakedTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LockerStakedTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LockerStakedTransaction_filter
  ): [LockerStakedTransaction!]!
  lockerTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LockerTransaction
  lockerTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LockerTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LockerTransaction_filter
  ): [LockerTransaction!]!
  lockerWithdrawnTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LockerWithdrawnTransaction
  lockerWithdrawnTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LockerWithdrawnTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LockerWithdrawnTransaction_filter
  ): [LockerWithdrawnTransaction!]!
  managementOperation(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ManagementOperation
  managementOperations(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ManagementOperation_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ManagementOperation_filter
  ): [ManagementOperation!]!
  masterChef(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MasterChef
  masterChefPoolInfo(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MasterChefPoolInfo
  masterChefPoolInfos(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MasterChefPoolInfo_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MasterChefPoolInfo_filter
  ): [MasterChefPoolInfo!]!
  masterChefUserInfo(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MasterChefUserInfo
  masterChefUserInfos(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MasterChefUserInfo_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MasterChefUserInfo_filter
  ): [MasterChefUserInfo!]!
  masterChefs(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MasterChef_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MasterChef_filter
  ): [MasterChef!]!
  merkleDrop(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MerkleDrop
  merkleDropClaim(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MerkleDropClaim
  merkleDropClaims(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MerkleDropClaim_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MerkleDropClaim_filter
  ): [MerkleDropClaim!]!
  merkleDrops(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MerkleDrop_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MerkleDrop_filter
  ): [MerkleDrop!]!
  pool(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pool
  poolAccount(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolAccount
  poolAccountRewards(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolAccountRewards_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolAccountRewards_filter
  ): [PoolAccountRewards!]!
  poolAccounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolAccount_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolAccount_filter
  ): [PoolAccount!]!
  poolContract(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolContract
  poolContracts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolContract_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolContract_filter
  ): [PoolContract!]!
  poolHistoricalLiquidities(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolHistoricalLiquidity_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolHistoricalLiquidity_filter
  ): [PoolHistoricalLiquidity!]!
  poolHistoricalLiquidity(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolHistoricalLiquidity
  poolRewardData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolRewardData
  poolRewardDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolRewardData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolRewardData_filter
  ): [PoolRewardData!]!
  poolRewardPaidTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolRewardPaidTransaction
  poolRewardPaidTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolRewardPaidTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolRewardPaidTransaction_filter
  ): [PoolRewardPaidTransaction!]!
  poolShare(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolShare
  poolShares(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolShare_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolShare_filter
  ): [PoolShare!]!
  poolSnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolSnapshot
  poolSnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolSnapshot_filter
  ): [PoolSnapshot!]!
  poolStakedTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolStakedTransaction
  poolStakedTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolStakedTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolStakedTransaction_filter
  ): [PoolStakedTransaction!]!
  poolToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolToken
  poolTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolToken_filter
  ): [PoolToken!]!
  poolTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolTransaction
  poolTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolTransaction_filter
  ): [PoolTransaction!]!
  poolWithdrawnTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolWithdrawnTransaction
  poolWithdrawnTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolWithdrawnTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolWithdrawnTransaction_filter
  ): [PoolWithdrawnTransaction!]!
  pools(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Pool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Pool_filter
  ): [Pool!]!
  priceRateProvider(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PriceRateProvider
  priceRateProviders(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PriceRateProvider_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PriceRateProvider_filter
  ): [PriceRateProvider!]!
  protocolIdData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ProtocolIdData
  protocolIdDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ProtocolIdData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ProtocolIdData_filter
  ): [ProtocolIdData!]!
  rewardData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardData
  rewardDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RewardData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RewardData_filter
  ): [RewardData!]!
  swap(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swapFeeUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SwapFeeUpdate
  swapFeeUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SwapFeeUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SwapFeeUpdate_filter
  ): [SwapFeeUpdate!]!
  swaps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Swap_filter
  ): [Swap!]!
  token(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokenPrice(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenPrice
  tokenPrices(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenPrice_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenPrice_filter
  ): [TokenPrice!]!
  tokenSnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenSnapshot
  tokenSnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenSnapshot_filter
  ): [TokenSnapshot!]!
  tokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Token_filter
  ): [Token!]!
  tradePair(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TradePair
  tradePairSnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TradePairSnapshot
  tradePairSnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TradePairSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TradePairSnapshot_filter
  ): [TradePairSnapshot!]!
  tradePairs(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TradePair_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TradePair_filter
  ): [TradePair!]!
  user(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  userInternalBalance(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserInternalBalance
  userInternalBalances(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserInternalBalance_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserInternalBalance_filter
  ): [UserInternalBalance!]!
  users(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: User_filter
  ): [User!]!
  vault(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Vault
  vaultAccount(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VaultAccount
  vaultAccountReward(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VaultAccountReward
  vaultAccountRewards(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VaultAccountReward_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VaultAccountReward_filter
  ): [VaultAccountReward!]!
  vaultAccounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VaultAccount_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VaultAccount_filter
  ): [VaultAccount!]!
  vaultDepositTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VaultDepositTransaction
  vaultDepositTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VaultDepositTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VaultDepositTransaction_filter
  ): [VaultDepositTransaction!]!
  vaultHarvestTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VaultHarvestTransaction
  vaultHarvestTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VaultHarvestTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VaultHarvestTransaction_filter
  ): [VaultHarvestTransaction!]!
  vaultRewardData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VaultRewardData
  vaultRewardDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VaultRewardData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VaultRewardData_filter
  ): [VaultRewardData!]!
  vaultRewardPaidTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VaultRewardPaidTransaction
  vaultRewardPaidTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VaultRewardPaidTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VaultRewardPaidTransaction_filter
  ): [VaultRewardPaidTransaction!]!
  vaultTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VaultTransaction
  vaultTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VaultTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VaultTransaction_filter
  ): [VaultTransaction!]!
  vaultWithdrawTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VaultWithdrawTransaction
  vaultWithdrawTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VaultWithdrawTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VaultWithdrawTransaction_filter
  ): [VaultWithdrawTransaction!]!
  vaults(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Vault_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Vault_filter
  ): [Vault!]!
}

type Swap {
  caller: Bytes!
  id: ID!
  poolId: Pool!
  timestamp: Int!
  tokenAmountIn: BigDecimal!
  tokenAmountOut: BigDecimal!
  tokenIn: Bytes!
  tokenInSym: String!
  tokenOut: Bytes!
  tokenOutSym: String!
  tx: Bytes!
  userAddress: User!
  valueUSD: BigDecimal!
}

type SwapFeeUpdate {
  endSwapFeePercentage: BigDecimal!
  endTimestamp: BigInt!
  id: ID!
  pool: Pool!
  scheduledTimestamp: Int!
  startSwapFeePercentage: BigDecimal!
  startTimestamp: BigInt!
}

input SwapFeeUpdate_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [SwapFeeUpdate_filter]
  endSwapFeePercentage: BigDecimal
  endSwapFeePercentage_gt: BigDecimal
  endSwapFeePercentage_gte: BigDecimal
  endSwapFeePercentage_in: [BigDecimal!]
  endSwapFeePercentage_lt: BigDecimal
  endSwapFeePercentage_lte: BigDecimal
  endSwapFeePercentage_not: BigDecimal
  endSwapFeePercentage_not_in: [BigDecimal!]
  endTimestamp: BigInt
  endTimestamp_gt: BigInt
  endTimestamp_gte: BigInt
  endTimestamp_in: [BigInt!]
  endTimestamp_lt: BigInt
  endTimestamp_lte: BigInt
  endTimestamp_not: BigInt
  endTimestamp_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [SwapFeeUpdate_filter]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  scheduledTimestamp: Int
  scheduledTimestamp_gt: Int
  scheduledTimestamp_gte: Int
  scheduledTimestamp_in: [Int!]
  scheduledTimestamp_lt: Int
  scheduledTimestamp_lte: Int
  scheduledTimestamp_not: Int
  scheduledTimestamp_not_in: [Int!]
  startSwapFeePercentage: BigDecimal
  startSwapFeePercentage_gt: BigDecimal
  startSwapFeePercentage_gte: BigDecimal
  startSwapFeePercentage_in: [BigDecimal!]
  startSwapFeePercentage_lt: BigDecimal
  startSwapFeePercentage_lte: BigDecimal
  startSwapFeePercentage_not: BigDecimal
  startSwapFeePercentage_not_in: [BigDecimal!]
  startTimestamp: BigInt
  startTimestamp_gt: BigInt
  startTimestamp_gte: BigInt
  startTimestamp_in: [BigInt!]
  startTimestamp_lt: BigInt
  startTimestamp_lte: BigInt
  startTimestamp_not: BigInt
  startTimestamp_not_in: [BigInt!]
}

enum SwapFeeUpdate_orderBy {
  endSwapFeePercentage
  endTimestamp
  id
  pool
  pool__address
  pool__alpha
  pool__amp
  pool__baseToken
  pool__beta
  pool__c
  pool__createTime
  pool__dSq
  pool__delta
  pool__epsilon
  pool__expiryTime
  pool__factory
  pool__holdersCount
  pool__id
  pool__isInRecoveryMode
  pool__isPaused
  pool__lambda
  pool__lastPostJoinExitInvariant
  pool__lowerTarget
  pool__mainIndex
  pool__managementFee
  pool__name
  pool__oracleEnabled
  pool__owner
  pool__poolType
  pool__poolTypeVersion
  pool__principalToken
  pool__protocolAumFeeCache
  pool__protocolId
  pool__protocolSwapFeeCache
  pool__protocolYieldFeeCache
  pool__root3Alpha
  pool__s
  pool__sqrtAlpha
  pool__sqrtBeta
  pool__strategyType
  pool__swapEnabled
  pool__swapFee
  pool__swapsCount
  pool__symbol
  pool__tauAlphaX
  pool__tauAlphaY
  pool__tauBetaX
  pool__tauBetaY
  pool__totalLiquidity
  pool__totalShares
  pool__totalSwapFee
  pool__totalSwapVolume
  pool__totalWeight
  pool__tx
  pool__u
  pool__unitSeconds
  pool__upperTarget
  pool__v
  pool__w
  pool__wrappedIndex
  pool__z
  scheduledTimestamp
  startSwapFeePercentage
  startTimestamp
}

input Swap_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Swap_filter]
  caller: Bytes
  caller_contains: Bytes
  caller_gt: Bytes
  caller_gte: Bytes
  caller_in: [Bytes!]
  caller_lt: Bytes
  caller_lte: Bytes
  caller_not: Bytes
  caller_not_contains: Bytes
  caller_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [Swap_filter]
  poolId: String
  poolId_: Pool_filter
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_gt: String
  poolId_gte: String
  poolId_in: [String!]
  poolId_lt: String
  poolId_lte: String
  poolId_not: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  poolId_not_in: [String!]
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  tokenAmountIn: BigDecimal
  tokenAmountIn_gt: BigDecimal
  tokenAmountIn_gte: BigDecimal
  tokenAmountIn_in: [BigDecimal!]
  tokenAmountIn_lt: BigDecimal
  tokenAmountIn_lte: BigDecimal
  tokenAmountIn_not: BigDecimal
  tokenAmountIn_not_in: [BigDecimal!]
  tokenAmountOut: BigDecimal
  tokenAmountOut_gt: BigDecimal
  tokenAmountOut_gte: BigDecimal
  tokenAmountOut_in: [BigDecimal!]
  tokenAmountOut_lt: BigDecimal
  tokenAmountOut_lte: BigDecimal
  tokenAmountOut_not: BigDecimal
  tokenAmountOut_not_in: [BigDecimal!]
  tokenIn: Bytes
  tokenInSym: String
  tokenInSym_contains: String
  tokenInSym_contains_nocase: String
  tokenInSym_ends_with: String
  tokenInSym_ends_with_nocase: String
  tokenInSym_gt: String
  tokenInSym_gte: String
  tokenInSym_in: [String!]
  tokenInSym_lt: String
  tokenInSym_lte: String
  tokenInSym_not: String
  tokenInSym_not_contains: String
  tokenInSym_not_contains_nocase: String
  tokenInSym_not_ends_with: String
  tokenInSym_not_ends_with_nocase: String
  tokenInSym_not_in: [String!]
  tokenInSym_not_starts_with: String
  tokenInSym_not_starts_with_nocase: String
  tokenInSym_starts_with: String
  tokenInSym_starts_with_nocase: String
  tokenIn_contains: Bytes
  tokenIn_gt: Bytes
  tokenIn_gte: Bytes
  tokenIn_in: [Bytes!]
  tokenIn_lt: Bytes
  tokenIn_lte: Bytes
  tokenIn_not: Bytes
  tokenIn_not_contains: Bytes
  tokenIn_not_in: [Bytes!]
  tokenOut: Bytes
  tokenOutSym: String
  tokenOutSym_contains: String
  tokenOutSym_contains_nocase: String
  tokenOutSym_ends_with: String
  tokenOutSym_ends_with_nocase: String
  tokenOutSym_gt: String
  tokenOutSym_gte: String
  tokenOutSym_in: [String!]
  tokenOutSym_lt: String
  tokenOutSym_lte: String
  tokenOutSym_not: String
  tokenOutSym_not_contains: String
  tokenOutSym_not_contains_nocase: String
  tokenOutSym_not_ends_with: String
  tokenOutSym_not_ends_with_nocase: String
  tokenOutSym_not_in: [String!]
  tokenOutSym_not_starts_with: String
  tokenOutSym_not_starts_with_nocase: String
  tokenOutSym_starts_with: String
  tokenOutSym_starts_with_nocase: String
  tokenOut_contains: Bytes
  tokenOut_gt: Bytes
  tokenOut_gte: Bytes
  tokenOut_in: [Bytes!]
  tokenOut_lt: Bytes
  tokenOut_lte: Bytes
  tokenOut_not: Bytes
  tokenOut_not_contains: Bytes
  tokenOut_not_in: [Bytes!]
  tx: Bytes
  tx_contains: Bytes
  tx_gt: Bytes
  tx_gte: Bytes
  tx_in: [Bytes!]
  tx_lt: Bytes
  tx_lte: Bytes
  tx_not: Bytes
  tx_not_contains: Bytes
  tx_not_in: [Bytes!]
  userAddress: String
  userAddress_: User_filter
  userAddress_contains: String
  userAddress_contains_nocase: String
  userAddress_ends_with: String
  userAddress_ends_with_nocase: String
  userAddress_gt: String
  userAddress_gte: String
  userAddress_in: [String!]
  userAddress_lt: String
  userAddress_lte: String
  userAddress_not: String
  userAddress_not_contains: String
  userAddress_not_contains_nocase: String
  userAddress_not_ends_with: String
  userAddress_not_ends_with_nocase: String
  userAddress_not_in: [String!]
  userAddress_not_starts_with: String
  userAddress_not_starts_with_nocase: String
  userAddress_starts_with: String
  userAddress_starts_with_nocase: String
  valueUSD: BigDecimal
  valueUSD_gt: BigDecimal
  valueUSD_gte: BigDecimal
  valueUSD_in: [BigDecimal!]
  valueUSD_lt: BigDecimal
  valueUSD_lte: BigDecimal
  valueUSD_not: BigDecimal
  valueUSD_not_in: [BigDecimal!]
}

enum Swap_orderBy {
  caller
  id
  poolId
  poolId__address
  poolId__alpha
  poolId__amp
  poolId__baseToken
  poolId__beta
  poolId__c
  poolId__createTime
  poolId__dSq
  poolId__delta
  poolId__epsilon
  poolId__expiryTime
  poolId__factory
  poolId__holdersCount
  poolId__id
  poolId__isInRecoveryMode
  poolId__isPaused
  poolId__lambda
  poolId__lastPostJoinExitInvariant
  poolId__lowerTarget
  poolId__mainIndex
  poolId__managementFee
  poolId__name
  poolId__oracleEnabled
  poolId__owner
  poolId__poolType
  poolId__poolTypeVersion
  poolId__principalToken
  poolId__protocolAumFeeCache
  poolId__protocolId
  poolId__protocolSwapFeeCache
  poolId__protocolYieldFeeCache
  poolId__root3Alpha
  poolId__s
  poolId__sqrtAlpha
  poolId__sqrtBeta
  poolId__strategyType
  poolId__swapEnabled
  poolId__swapFee
  poolId__swapsCount
  poolId__symbol
  poolId__tauAlphaX
  poolId__tauAlphaY
  poolId__tauBetaX
  poolId__tauBetaY
  poolId__totalLiquidity
  poolId__totalShares
  poolId__totalSwapFee
  poolId__totalSwapVolume
  poolId__totalWeight
  poolId__tx
  poolId__u
  poolId__unitSeconds
  poolId__upperTarget
  poolId__v
  poolId__w
  poolId__wrappedIndex
  poolId__z
  timestamp
  tokenAmountIn
  tokenAmountOut
  tokenIn
  tokenInSym
  tokenOut
  tokenOutSym
  tx
  userAddress
  userAddress__id
  valueUSD
}

type Token {
  address: String!
  decimals: Int!

  """
  Address
  """
  id: ID!
  latestFXPrice: BigDecimal
  latestPrice: LatestPrice
  latestUSDPrice: BigDecimal
  latestUSDPriceTimestamp: BigInt
  name: String!
  pool: Pool
  symbol: String!
  totalBalanceNotional: BigDecimal!
  totalBalanceUSD: BigDecimal!
  totalSwapCount: BigInt!
  totalVolumeNotional: BigDecimal!
  totalVolumeUSD: BigDecimal!
}

type TokenPrice {
  amount: BigDecimal!
  asset: Bytes!
  block: BigInt!
  id: ID!
  poolId: Pool!
  price: BigDecimal!
  pricingAsset: Bytes!
  timestamp: Int!
}

input TokenPrice_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  and: [TokenPrice_filter]
  asset: Bytes
  asset_contains: Bytes
  asset_gt: Bytes
  asset_gte: Bytes
  asset_in: [Bytes!]
  asset_lt: Bytes
  asset_lte: Bytes
  asset_not: Bytes
  asset_not_contains: Bytes
  asset_not_in: [Bytes!]
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [TokenPrice_filter]
  poolId: String
  poolId_: Pool_filter
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_gt: String
  poolId_gte: String
  poolId_in: [String!]
  poolId_lt: String
  poolId_lte: String
  poolId_not: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  poolId_not_in: [String!]
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  price: BigDecimal
  price_gt: BigDecimal
  price_gte: BigDecimal
  price_in: [BigDecimal!]
  price_lt: BigDecimal
  price_lte: BigDecimal
  price_not: BigDecimal
  price_not_in: [BigDecimal!]
  pricingAsset: Bytes
  pricingAsset_contains: Bytes
  pricingAsset_gt: Bytes
  pricingAsset_gte: Bytes
  pricingAsset_in: [Bytes!]
  pricingAsset_lt: Bytes
  pricingAsset_lte: Bytes
  pricingAsset_not: Bytes
  pricingAsset_not_contains: Bytes
  pricingAsset_not_in: [Bytes!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
}

enum TokenPrice_orderBy {
  amount
  asset
  block
  id
  poolId
  poolId__address
  poolId__alpha
  poolId__amp
  poolId__baseToken
  poolId__beta
  poolId__c
  poolId__createTime
  poolId__dSq
  poolId__delta
  poolId__epsilon
  poolId__expiryTime
  poolId__factory
  poolId__holdersCount
  poolId__id
  poolId__isInRecoveryMode
  poolId__isPaused
  poolId__lambda
  poolId__lastPostJoinExitInvariant
  poolId__lowerTarget
  poolId__mainIndex
  poolId__managementFee
  poolId__name
  poolId__oracleEnabled
  poolId__owner
  poolId__poolType
  poolId__poolTypeVersion
  poolId__principalToken
  poolId__protocolAumFeeCache
  poolId__protocolId
  poolId__protocolSwapFeeCache
  poolId__protocolYieldFeeCache
  poolId__root3Alpha
  poolId__s
  poolId__sqrtAlpha
  poolId__sqrtBeta
  poolId__strategyType
  poolId__swapEnabled
  poolId__swapFee
  poolId__swapsCount
  poolId__symbol
  poolId__tauAlphaX
  poolId__tauAlphaY
  poolId__tauBetaX
  poolId__tauBetaY
  poolId__totalLiquidity
  poolId__totalShares
  poolId__totalSwapFee
  poolId__totalSwapVolume
  poolId__totalWeight
  poolId__tx
  poolId__u
  poolId__unitSeconds
  poolId__upperTarget
  poolId__v
  poolId__w
  poolId__wrappedIndex
  poolId__z
  price
  pricingAsset
  timestamp
}

type TokenSnapshot {
  id: ID!
  timestamp: Int!
  token: Token!
  totalBalanceNotional: BigDecimal!
  totalBalanceUSD: BigDecimal!
  totalSwapCount: BigInt!
  totalVolumeNotional: BigDecimal!
  totalVolumeUSD: BigDecimal!
}

input TokenSnapshot_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [TokenSnapshot_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [TokenSnapshot_filter]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  totalBalanceNotional: BigDecimal
  totalBalanceNotional_gt: BigDecimal
  totalBalanceNotional_gte: BigDecimal
  totalBalanceNotional_in: [BigDecimal!]
  totalBalanceNotional_lt: BigDecimal
  totalBalanceNotional_lte: BigDecimal
  totalBalanceNotional_not: BigDecimal
  totalBalanceNotional_not_in: [BigDecimal!]
  totalBalanceUSD: BigDecimal
  totalBalanceUSD_gt: BigDecimal
  totalBalanceUSD_gte: BigDecimal
  totalBalanceUSD_in: [BigDecimal!]
  totalBalanceUSD_lt: BigDecimal
  totalBalanceUSD_lte: BigDecimal
  totalBalanceUSD_not: BigDecimal
  totalBalanceUSD_not_in: [BigDecimal!]
  totalSwapCount: BigInt
  totalSwapCount_gt: BigInt
  totalSwapCount_gte: BigInt
  totalSwapCount_in: [BigInt!]
  totalSwapCount_lt: BigInt
  totalSwapCount_lte: BigInt
  totalSwapCount_not: BigInt
  totalSwapCount_not_in: [BigInt!]
  totalVolumeNotional: BigDecimal
  totalVolumeNotional_gt: BigDecimal
  totalVolumeNotional_gte: BigDecimal
  totalVolumeNotional_in: [BigDecimal!]
  totalVolumeNotional_lt: BigDecimal
  totalVolumeNotional_lte: BigDecimal
  totalVolumeNotional_not: BigDecimal
  totalVolumeNotional_not_in: [BigDecimal!]
  totalVolumeUSD: BigDecimal
  totalVolumeUSD_gt: BigDecimal
  totalVolumeUSD_gte: BigDecimal
  totalVolumeUSD_in: [BigDecimal!]
  totalVolumeUSD_lt: BigDecimal
  totalVolumeUSD_lte: BigDecimal
  totalVolumeUSD_not: BigDecimal
  totalVolumeUSD_not_in: [BigDecimal!]
}

enum TokenSnapshot_orderBy {
  id
  timestamp
  token
  token__address
  token__decimals
  token__id
  token__latestFXPrice
  token__latestUSDPrice
  token__latestUSDPriceTimestamp
  token__name
  token__symbol
  token__totalBalanceNotional
  token__totalBalanceUSD
  token__totalSwapCount
  token__totalVolumeNotional
  token__totalVolumeUSD
  totalBalanceNotional
  totalBalanceUSD
  totalSwapCount
  totalVolumeNotional
  totalVolumeUSD
}

input Token_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  address: String
  address_contains: String
  address_contains_nocase: String
  address_ends_with: String
  address_ends_with_nocase: String
  address_gt: String
  address_gte: String
  address_in: [String!]
  address_lt: String
  address_lte: String
  address_not: String
  address_not_contains: String
  address_not_contains_nocase: String
  address_not_ends_with: String
  address_not_ends_with_nocase: String
  address_not_in: [String!]
  address_not_starts_with: String
  address_not_starts_with_nocase: String
  address_starts_with: String
  address_starts_with_nocase: String
  and: [Token_filter]
  decimals: Int
  decimals_gt: Int
  decimals_gte: Int
  decimals_in: [Int!]
  decimals_lt: Int
  decimals_lte: Int
  decimals_not: Int
  decimals_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  latestFXPrice: BigDecimal
  latestFXPrice_gt: BigDecimal
  latestFXPrice_gte: BigDecimal
  latestFXPrice_in: [BigDecimal!]
  latestFXPrice_lt: BigDecimal
  latestFXPrice_lte: BigDecimal
  latestFXPrice_not: BigDecimal
  latestFXPrice_not_in: [BigDecimal!]
  latestPrice: String
  latestPrice_: LatestPrice_filter
  latestPrice_contains: String
  latestPrice_contains_nocase: String
  latestPrice_ends_with: String
  latestPrice_ends_with_nocase: String
  latestPrice_gt: String
  latestPrice_gte: String
  latestPrice_in: [String!]
  latestPrice_lt: String
  latestPrice_lte: String
  latestPrice_not: String
  latestPrice_not_contains: String
  latestPrice_not_contains_nocase: String
  latestPrice_not_ends_with: String
  latestPrice_not_ends_with_nocase: String
  latestPrice_not_in: [String!]
  latestPrice_not_starts_with: String
  latestPrice_not_starts_with_nocase: String
  latestPrice_starts_with: String
  latestPrice_starts_with_nocase: String
  latestUSDPrice: BigDecimal
  latestUSDPriceTimestamp: BigInt
  latestUSDPriceTimestamp_gt: BigInt
  latestUSDPriceTimestamp_gte: BigInt
  latestUSDPriceTimestamp_in: [BigInt!]
  latestUSDPriceTimestamp_lt: BigInt
  latestUSDPriceTimestamp_lte: BigInt
  latestUSDPriceTimestamp_not: BigInt
  latestUSDPriceTimestamp_not_in: [BigInt!]
  latestUSDPrice_gt: BigDecimal
  latestUSDPrice_gte: BigDecimal
  latestUSDPrice_in: [BigDecimal!]
  latestUSDPrice_lt: BigDecimal
  latestUSDPrice_lte: BigDecimal
  latestUSDPrice_not: BigDecimal
  latestUSDPrice_not_in: [BigDecimal!]
  name: String
  name_contains: String
  name_contains_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  or: [Token_filter]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  symbol: String
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  totalBalanceNotional: BigDecimal
  totalBalanceNotional_gt: BigDecimal
  totalBalanceNotional_gte: BigDecimal
  totalBalanceNotional_in: [BigDecimal!]
  totalBalanceNotional_lt: BigDecimal
  totalBalanceNotional_lte: BigDecimal
  totalBalanceNotional_not: BigDecimal
  totalBalanceNotional_not_in: [BigDecimal!]
  totalBalanceUSD: BigDecimal
  totalBalanceUSD_gt: BigDecimal
  totalBalanceUSD_gte: BigDecimal
  totalBalanceUSD_in: [BigDecimal!]
  totalBalanceUSD_lt: BigDecimal
  totalBalanceUSD_lte: BigDecimal
  totalBalanceUSD_not: BigDecimal
  totalBalanceUSD_not_in: [BigDecimal!]
  totalSwapCount: BigInt
  totalSwapCount_gt: BigInt
  totalSwapCount_gte: BigInt
  totalSwapCount_in: [BigInt!]
  totalSwapCount_lt: BigInt
  totalSwapCount_lte: BigInt
  totalSwapCount_not: BigInt
  totalSwapCount_not_in: [BigInt!]
  totalVolumeNotional: BigDecimal
  totalVolumeNotional_gt: BigDecimal
  totalVolumeNotional_gte: BigDecimal
  totalVolumeNotional_in: [BigDecimal!]
  totalVolumeNotional_lt: BigDecimal
  totalVolumeNotional_lte: BigDecimal
  totalVolumeNotional_not: BigDecimal
  totalVolumeNotional_not_in: [BigDecimal!]
  totalVolumeUSD: BigDecimal
  totalVolumeUSD_gt: BigDecimal
  totalVolumeUSD_gte: BigDecimal
  totalVolumeUSD_in: [BigDecimal!]
  totalVolumeUSD_lt: BigDecimal
  totalVolumeUSD_lte: BigDecimal
  totalVolumeUSD_not: BigDecimal
  totalVolumeUSD_not_in: [BigDecimal!]
}

enum Token_orderBy {
  address
  decimals
  id
  latestFXPrice
  latestPrice
  latestPrice__asset
  latestPrice__block
  latestPrice__id
  latestPrice__price
  latestPrice__pricingAsset
  latestUSDPrice
  latestUSDPriceTimestamp
  name
  pool
  pool__address
  pool__alpha
  pool__amp
  pool__baseToken
  pool__beta
  pool__c
  pool__createTime
  pool__dSq
  pool__delta
  pool__epsilon
  pool__expiryTime
  pool__factory
  pool__holdersCount
  pool__id
  pool__isInRecoveryMode
  pool__isPaused
  pool__lambda
  pool__lastPostJoinExitInvariant
  pool__lowerTarget
  pool__mainIndex
  pool__managementFee
  pool__name
  pool__oracleEnabled
  pool__owner
  pool__poolType
  pool__poolTypeVersion
  pool__principalToken
  pool__protocolAumFeeCache
  pool__protocolId
  pool__protocolSwapFeeCache
  pool__protocolYieldFeeCache
  pool__root3Alpha
  pool__s
  pool__sqrtAlpha
  pool__sqrtBeta
  pool__strategyType
  pool__swapEnabled
  pool__swapFee
  pool__swapsCount
  pool__symbol
  pool__tauAlphaX
  pool__tauAlphaY
  pool__tauBetaX
  pool__tauBetaY
  pool__totalLiquidity
  pool__totalShares
  pool__totalSwapFee
  pool__totalSwapVolume
  pool__totalWeight
  pool__tx
  pool__u
  pool__unitSeconds
  pool__upperTarget
  pool__v
  pool__w
  pool__wrappedIndex
  pool__z
  symbol
  totalBalanceNotional
  totalBalanceUSD
  totalSwapCount
  totalVolumeNotional
  totalVolumeUSD
}

type TradePair {
  """
  Token Address - Token Address
  """
  id: ID!
  token0: Token!
  token1: Token!
  totalSwapFee: BigDecimal!
  totalSwapVolume: BigDecimal!
}

type TradePairSnapshot {
  id: ID!
  pair: TradePair!
  timestamp: Int!
  totalSwapFee: BigDecimal!
  totalSwapVolume: BigDecimal!
}

input TradePairSnapshot_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [TradePairSnapshot_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [TradePairSnapshot_filter]
  pair: String
  pair_: TradePair_filter
  pair_contains: String
  pair_contains_nocase: String
  pair_ends_with: String
  pair_ends_with_nocase: String
  pair_gt: String
  pair_gte: String
  pair_in: [String!]
  pair_lt: String
  pair_lte: String
  pair_not: String
  pair_not_contains: String
  pair_not_contains_nocase: String
  pair_not_ends_with: String
  pair_not_ends_with_nocase: String
  pair_not_in: [String!]
  pair_not_starts_with: String
  pair_not_starts_with_nocase: String
  pair_starts_with: String
  pair_starts_with_nocase: String
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  totalSwapFee: BigDecimal
  totalSwapFee_gt: BigDecimal
  totalSwapFee_gte: BigDecimal
  totalSwapFee_in: [BigDecimal!]
  totalSwapFee_lt: BigDecimal
  totalSwapFee_lte: BigDecimal
  totalSwapFee_not: BigDecimal
  totalSwapFee_not_in: [BigDecimal!]
  totalSwapVolume: BigDecimal
  totalSwapVolume_gt: BigDecimal
  totalSwapVolume_gte: BigDecimal
  totalSwapVolume_in: [BigDecimal!]
  totalSwapVolume_lt: BigDecimal
  totalSwapVolume_lte: BigDecimal
  totalSwapVolume_not: BigDecimal
  totalSwapVolume_not_in: [BigDecimal!]
}

enum TradePairSnapshot_orderBy {
  id
  pair
  pair__id
  pair__totalSwapFee
  pair__totalSwapVolume
  timestamp
  totalSwapFee
  totalSwapVolume
}

input TradePair_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [TradePair_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [TradePair_filter]
  token0: String
  token0_: Token_filter
  token0_contains: String
  token0_contains_nocase: String
  token0_ends_with: String
  token0_ends_with_nocase: String
  token0_gt: String
  token0_gte: String
  token0_in: [String!]
  token0_lt: String
  token0_lte: String
  token0_not: String
  token0_not_contains: String
  token0_not_contains_nocase: String
  token0_not_ends_with: String
  token0_not_ends_with_nocase: String
  token0_not_in: [String!]
  token0_not_starts_with: String
  token0_not_starts_with_nocase: String
  token0_starts_with: String
  token0_starts_with_nocase: String
  token1: String
  token1_: Token_filter
  token1_contains: String
  token1_contains_nocase: String
  token1_ends_with: String
  token1_ends_with_nocase: String
  token1_gt: String
  token1_gte: String
  token1_in: [String!]
  token1_lt: String
  token1_lte: String
  token1_not: String
  token1_not_contains: String
  token1_not_contains_nocase: String
  token1_not_ends_with: String
  token1_not_ends_with_nocase: String
  token1_not_in: [String!]
  token1_not_starts_with: String
  token1_not_starts_with_nocase: String
  token1_starts_with: String
  token1_starts_with_nocase: String
  totalSwapFee: BigDecimal
  totalSwapFee_gt: BigDecimal
  totalSwapFee_gte: BigDecimal
  totalSwapFee_in: [BigDecimal!]
  totalSwapFee_lt: BigDecimal
  totalSwapFee_lte: BigDecimal
  totalSwapFee_not: BigDecimal
  totalSwapFee_not_in: [BigDecimal!]
  totalSwapVolume: BigDecimal
  totalSwapVolume_gt: BigDecimal
  totalSwapVolume_gte: BigDecimal
  totalSwapVolume_in: [BigDecimal!]
  totalSwapVolume_lt: BigDecimal
  totalSwapVolume_lte: BigDecimal
  totalSwapVolume_not: BigDecimal
  totalSwapVolume_not_in: [BigDecimal!]
}

enum TradePair_orderBy {
  id
  token0
  token0__address
  token0__decimals
  token0__id
  token0__latestFXPrice
  token0__latestUSDPrice
  token0__latestUSDPriceTimestamp
  token0__name
  token0__symbol
  token0__totalBalanceNotional
  token0__totalBalanceUSD
  token0__totalSwapCount
  token0__totalVolumeNotional
  token0__totalVolumeUSD
  token1
  token1__address
  token1__decimals
  token1__id
  token1__latestFXPrice
  token1__latestUSDPrice
  token1__latestUSDPriceTimestamp
  token1__name
  token1__symbol
  token1__totalBalanceNotional
  token1__totalBalanceUSD
  token1__totalSwapCount
  token1__totalVolumeNotional
  token1__totalVolumeUSD
  totalSwapFee
  totalSwapVolume
}

type User {
  id: ID!
  sharesOwned(
    first: Int = 100
    orderBy: PoolShare_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: PoolShare_filter
  ): [PoolShare!]
  swaps(
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Swap_filter
  ): [Swap!]
  userInternalBalances(
    first: Int = 100
    orderBy: UserInternalBalance_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: UserInternalBalance_filter
  ): [UserInternalBalance!]
}

type UserInternalBalance {
  balance: BigDecimal!
  id: ID!
  token: Bytes!
  userAddress: User
}

input UserInternalBalance_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [UserInternalBalance_filter]
  balance: BigDecimal
  balance_gt: BigDecimal
  balance_gte: BigDecimal
  balance_in: [BigDecimal!]
  balance_lt: BigDecimal
  balance_lte: BigDecimal
  balance_not: BigDecimal
  balance_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [UserInternalBalance_filter]
  token: Bytes
  token_contains: Bytes
  token_gt: Bytes
  token_gte: Bytes
  token_in: [Bytes!]
  token_lt: Bytes
  token_lte: Bytes
  token_not: Bytes
  token_not_contains: Bytes
  token_not_in: [Bytes!]
  userAddress: String
  userAddress_: User_filter
  userAddress_contains: String
  userAddress_contains_nocase: String
  userAddress_ends_with: String
  userAddress_ends_with_nocase: String
  userAddress_gt: String
  userAddress_gte: String
  userAddress_in: [String!]
  userAddress_lt: String
  userAddress_lte: String
  userAddress_not: String
  userAddress_not_contains: String
  userAddress_not_contains_nocase: String
  userAddress_not_ends_with: String
  userAddress_not_ends_with_nocase: String
  userAddress_not_in: [String!]
  userAddress_not_starts_with: String
  userAddress_not_starts_with_nocase: String
  userAddress_starts_with: String
  userAddress_starts_with_nocase: String
}

enum UserInternalBalance_orderBy {
  balance
  id
  token
  userAddress
  userAddress__id
}

input User_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [User_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [User_filter]
  sharesOwned_: PoolShare_filter
  swaps_: Swap_filter
  userInternalBalances_: UserInternalBalance_filter
}

enum User_orderBy {
  id
  sharesOwned
  swaps
  userInternalBalances
}

"""
ERC-4626 Vault
"""
type Vault {
  accounts(
    first: Int = 100
    orderBy: VaultAccount_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: VaultAccount_filter
  ): [VaultAccount!]!
  asset: Token!
  decimals: Int!
  depositTransactions(
    first: Int = 100
    orderBy: VaultDepositTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: VaultDepositTransaction_filter
  ): [VaultDepositTransaction!]!
  harvestTransactions(
    first: Int = 100
    orderBy: VaultHarvestTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: VaultHarvestTransaction_filter
  ): [VaultHarvestTransaction!]!

  """
  Vault address
  """
  id: ID!
  name: String!
  rewardData(
    first: Int = 100
    orderBy: VaultRewardData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: VaultRewardData_filter
  ): [VaultRewardData!]!
  rewardPaidTransactions(
    first: Int = 100
    orderBy: VaultRewardPaidTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: VaultRewardPaidTransaction_filter
  ): [VaultRewardPaidTransaction!]!
  strategy: Bytes!
  symbol: String!
  totalSupply: BigInt!

  """
  Note that this field may not reflect the current value, as it is not updated on every
  transfer event; rather, it is updated on deposit/stake/harvest.
  """
  totalUnderlying: BigInt!
  underlying: Token!
  withdrawTransactions(
    first: Int = 100
    orderBy: VaultWithdrawTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: VaultWithdrawTransaction_filter
  ): [VaultWithdrawTransaction!]!
}

type VaultAccount {
  account: Account!
  depositTransactions(
    first: Int = 100
    orderBy: VaultDepositTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: VaultDepositTransaction_filter
  ): [VaultDepositTransaction!]!
  harvestTransactions(
    first: Int = 100
    orderBy: VaultHarvestTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: VaultHarvestTransaction_filter
  ): [VaultHarvestTransaction!]!

  """
  {Vault.id}.{Account.id}
  """
  id: ID!
  rewardPaidTransactions(
    first: Int = 100
    orderBy: VaultRewardPaidTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: VaultRewardPaidTransaction_filter
  ): [VaultRewardPaidTransaction!]!
  rewards(
    first: Int = 100
    orderBy: VaultAccountReward_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: VaultAccountReward_filter
  ): [VaultAccountReward!]!
  shares: BigInt!
  vault: Vault!
  withdrawTransactions(
    first: Int = 100
    orderBy: VaultWithdrawTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: VaultWithdrawTransaction_filter
  ): [VaultWithdrawTransaction!]!
}

type VaultAccountReward {
  """
  {rewardsToken.id}.{vaultAccount.id}
  """
  id: ID!

  """
  userRewardPerTokenPaid(account)
  """
  rewardPerTokenPaid: BigInt!
  rewardToken: Token!

  """
  rewards(account)
  """
  rewards: BigInt!
  vaultAccount: VaultAccount!
}

input VaultAccountReward_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  rewardPerTokenPaid: BigInt
  rewardPerTokenPaid_gt: BigInt
  rewardPerTokenPaid_gte: BigInt
  rewardPerTokenPaid_in: [BigInt!]
  rewardPerTokenPaid_lt: BigInt
  rewardPerTokenPaid_lte: BigInt
  rewardPerTokenPaid_not: BigInt
  rewardPerTokenPaid_not_in: [BigInt!]
  rewardToken: String
  rewardToken_: Token_filter
  rewardToken_contains: String
  rewardToken_contains_nocase: String
  rewardToken_ends_with: String
  rewardToken_ends_with_nocase: String
  rewardToken_gt: String
  rewardToken_gte: String
  rewardToken_in: [String!]
  rewardToken_lt: String
  rewardToken_lte: String
  rewardToken_not: String
  rewardToken_not_contains: String
  rewardToken_not_contains_nocase: String
  rewardToken_not_ends_with: String
  rewardToken_not_ends_with_nocase: String
  rewardToken_not_in: [String!]
  rewardToken_not_starts_with: String
  rewardToken_not_starts_with_nocase: String
  rewardToken_starts_with: String
  rewardToken_starts_with_nocase: String
  rewards: BigInt
  rewards_gt: BigInt
  rewards_gte: BigInt
  rewards_in: [BigInt!]
  rewards_lt: BigInt
  rewards_lte: BigInt
  rewards_not: BigInt
  rewards_not_in: [BigInt!]
  vaultAccount: String
  vaultAccount_: VaultAccount_filter
  vaultAccount_contains: String
  vaultAccount_contains_nocase: String
  vaultAccount_ends_with: String
  vaultAccount_ends_with_nocase: String
  vaultAccount_gt: String
  vaultAccount_gte: String
  vaultAccount_in: [String!]
  vaultAccount_lt: String
  vaultAccount_lte: String
  vaultAccount_not: String
  vaultAccount_not_contains: String
  vaultAccount_not_contains_nocase: String
  vaultAccount_not_ends_with: String
  vaultAccount_not_ends_with_nocase: String
  vaultAccount_not_in: [String!]
  vaultAccount_not_starts_with: String
  vaultAccount_not_starts_with_nocase: String
  vaultAccount_starts_with: String
  vaultAccount_starts_with_nocase: String
}

enum VaultAccountReward_orderBy {
  id
  rewardPerTokenPaid
  rewardToken
  rewards
  vaultAccount
}

input VaultAccount_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  account: String
  account_: Account_filter
  account_contains: String
  account_contains_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_gt: String
  account_gte: String
  account_in: [String!]
  account_lt: String
  account_lte: String
  account_not: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_not_in: [String!]
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  depositTransactions_: VaultDepositTransaction_filter
  harvestTransactions_: VaultHarvestTransaction_filter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  rewardPaidTransactions_: VaultRewardPaidTransaction_filter
  rewards_: VaultAccountReward_filter
  shares: BigInt
  shares_gt: BigInt
  shares_gte: BigInt
  shares_in: [BigInt!]
  shares_lt: BigInt
  shares_lte: BigInt
  shares_not: BigInt
  shares_not_in: [BigInt!]
  vault: String
  vault_: Vault_filter
  vault_contains: String
  vault_contains_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_gt: String
  vault_gte: String
  vault_in: [String!]
  vault_lt: String
  vault_lte: String
  vault_not: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_not_in: [String!]
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  withdrawTransactions_: VaultWithdrawTransaction_filter
}

enum VaultAccount_orderBy {
  account
  depositTransactions
  harvestTransactions
  id
  rewardPaidTransactions
  rewards
  shares
  vault
  withdrawTransactions
}

type VaultDepositTransaction implements VaultTransaction {
  assets: BigInt!
  hash: Bytes!
  id: ID!
  owner: Bytes!
  sender: Bytes!
  shares: BigInt!
  timestamp: Int!
  vault: Vault!
  vaultAccount: VaultAccount!
}

input VaultDepositTransaction_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  assets: BigInt
  assets_gt: BigInt
  assets_gte: BigInt
  assets_in: [BigInt!]
  assets_lt: BigInt
  assets_lte: BigInt
  assets_not: BigInt
  assets_not_in: [BigInt!]
  hash: Bytes
  hash_contains: Bytes
  hash_in: [Bytes!]
  hash_not: Bytes
  hash_not_contains: Bytes
  hash_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  owner: Bytes
  owner_contains: Bytes
  owner_in: [Bytes!]
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  sender: Bytes
  sender_contains: Bytes
  sender_in: [Bytes!]
  sender_not: Bytes
  sender_not_contains: Bytes
  sender_not_in: [Bytes!]
  shares: BigInt
  shares_gt: BigInt
  shares_gte: BigInt
  shares_in: [BigInt!]
  shares_lt: BigInt
  shares_lte: BigInt
  shares_not: BigInt
  shares_not_in: [BigInt!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  vault: String
  vaultAccount: String
  vaultAccount_: VaultAccount_filter
  vaultAccount_contains: String
  vaultAccount_contains_nocase: String
  vaultAccount_ends_with: String
  vaultAccount_ends_with_nocase: String
  vaultAccount_gt: String
  vaultAccount_gte: String
  vaultAccount_in: [String!]
  vaultAccount_lt: String
  vaultAccount_lte: String
  vaultAccount_not: String
  vaultAccount_not_contains: String
  vaultAccount_not_contains_nocase: String
  vaultAccount_not_ends_with: String
  vaultAccount_not_ends_with_nocase: String
  vaultAccount_not_in: [String!]
  vaultAccount_not_starts_with: String
  vaultAccount_not_starts_with_nocase: String
  vaultAccount_starts_with: String
  vaultAccount_starts_with_nocase: String
  vault_: Vault_filter
  vault_contains: String
  vault_contains_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_gt: String
  vault_gte: String
  vault_in: [String!]
  vault_lt: String
  vault_lte: String
  vault_not: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_not_in: [String!]
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
}

enum VaultDepositTransaction_orderBy {
  assets
  hash
  id
  owner
  sender
  shares
  timestamp
  vault
  vaultAccount
}

type VaultHarvestTransaction implements VaultTransaction {
  harvested: BigInt!
  hash: Bytes!
  id: ID!
  sender: Bytes!
  timestamp: Int!
  vault: Vault!
  vaultAccount: VaultAccount!
}

input VaultHarvestTransaction_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  harvested: BigInt
  harvested_gt: BigInt
  harvested_gte: BigInt
  harvested_in: [BigInt!]
  harvested_lt: BigInt
  harvested_lte: BigInt
  harvested_not: BigInt
  harvested_not_in: [BigInt!]
  hash: Bytes
  hash_contains: Bytes
  hash_in: [Bytes!]
  hash_not: Bytes
  hash_not_contains: Bytes
  hash_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  sender: Bytes
  sender_contains: Bytes
  sender_in: [Bytes!]
  sender_not: Bytes
  sender_not_contains: Bytes
  sender_not_in: [Bytes!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  vault: String
  vaultAccount: String
  vaultAccount_: VaultAccount_filter
  vaultAccount_contains: String
  vaultAccount_contains_nocase: String
  vaultAccount_ends_with: String
  vaultAccount_ends_with_nocase: String
  vaultAccount_gt: String
  vaultAccount_gte: String
  vaultAccount_in: [String!]
  vaultAccount_lt: String
  vaultAccount_lte: String
  vaultAccount_not: String
  vaultAccount_not_contains: String
  vaultAccount_not_contains_nocase: String
  vaultAccount_not_ends_with: String
  vaultAccount_not_ends_with_nocase: String
  vaultAccount_not_in: [String!]
  vaultAccount_not_starts_with: String
  vaultAccount_not_starts_with_nocase: String
  vaultAccount_starts_with: String
  vaultAccount_starts_with_nocase: String
  vault_: Vault_filter
  vault_contains: String
  vault_contains_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_gt: String
  vault_gte: String
  vault_in: [String!]
  vault_lt: String
  vault_lte: String
  vault_not: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_not_in: [String!]
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
}

enum VaultHarvestTransaction_orderBy {
  harvested
  hash
  id
  sender
  timestamp
  vault
  vaultAccount
}

type VaultRewardData implements RewardData {
  """
  {Vault.id}.{token.id}
  """
  id: ID!
  lastUpdateTime: Int!
  periodFinish: Int!
  queuedRewards: BigInt!
  rewardPerTokenStored: BigInt!
  rewardRate: BigInt!
  token: Token!
  vault: Vault
}

input VaultRewardData_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lastUpdateTime: Int
  lastUpdateTime_gt: Int
  lastUpdateTime_gte: Int
  lastUpdateTime_in: [Int!]
  lastUpdateTime_lt: Int
  lastUpdateTime_lte: Int
  lastUpdateTime_not: Int
  lastUpdateTime_not_in: [Int!]
  periodFinish: Int
  periodFinish_gt: Int
  periodFinish_gte: Int
  periodFinish_in: [Int!]
  periodFinish_lt: Int
  periodFinish_lte: Int
  periodFinish_not: Int
  periodFinish_not_in: [Int!]
  queuedRewards: BigInt
  queuedRewards_gt: BigInt
  queuedRewards_gte: BigInt
  queuedRewards_in: [BigInt!]
  queuedRewards_lt: BigInt
  queuedRewards_lte: BigInt
  queuedRewards_not: BigInt
  queuedRewards_not_in: [BigInt!]
  rewardPerTokenStored: BigInt
  rewardPerTokenStored_gt: BigInt
  rewardPerTokenStored_gte: BigInt
  rewardPerTokenStored_in: [BigInt!]
  rewardPerTokenStored_lt: BigInt
  rewardPerTokenStored_lte: BigInt
  rewardPerTokenStored_not: BigInt
  rewardPerTokenStored_not_in: [BigInt!]
  rewardRate: BigInt
  rewardRate_gt: BigInt
  rewardRate_gte: BigInt
  rewardRate_in: [BigInt!]
  rewardRate_lt: BigInt
  rewardRate_lte: BigInt
  rewardRate_not: BigInt
  rewardRate_not_in: [BigInt!]
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  vault: String
  vault_: Vault_filter
  vault_contains: String
  vault_contains_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_gt: String
  vault_gte: String
  vault_in: [String!]
  vault_lt: String
  vault_lte: String
  vault_not: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_not_in: [String!]
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
}

enum VaultRewardData_orderBy {
  id
  lastUpdateTime
  periodFinish
  queuedRewards
  rewardPerTokenStored
  rewardRate
  token
  vault
}

type VaultRewardPaidTransaction implements VaultTransaction {
  hash: Bytes!
  id: ID!
  reward: BigInt!
  rewardData: VaultRewardData!
  timestamp: Int!
  vault: Vault!
  vaultAccount: VaultAccount!
}

input VaultRewardPaidTransaction_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  hash: Bytes
  hash_contains: Bytes
  hash_in: [Bytes!]
  hash_not: Bytes
  hash_not_contains: Bytes
  hash_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  reward: BigInt
  rewardData: String
  rewardData_: VaultRewardData_filter
  rewardData_contains: String
  rewardData_contains_nocase: String
  rewardData_ends_with: String
  rewardData_ends_with_nocase: String
  rewardData_gt: String
  rewardData_gte: String
  rewardData_in: [String!]
  rewardData_lt: String
  rewardData_lte: String
  rewardData_not: String
  rewardData_not_contains: String
  rewardData_not_contains_nocase: String
  rewardData_not_ends_with: String
  rewardData_not_ends_with_nocase: String
  rewardData_not_in: [String!]
  rewardData_not_starts_with: String
  rewardData_not_starts_with_nocase: String
  rewardData_starts_with: String
  rewardData_starts_with_nocase: String
  reward_gt: BigInt
  reward_gte: BigInt
  reward_in: [BigInt!]
  reward_lt: BigInt
  reward_lte: BigInt
  reward_not: BigInt
  reward_not_in: [BigInt!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  vault: String
  vaultAccount: String
  vaultAccount_: VaultAccount_filter
  vaultAccount_contains: String
  vaultAccount_contains_nocase: String
  vaultAccount_ends_with: String
  vaultAccount_ends_with_nocase: String
  vaultAccount_gt: String
  vaultAccount_gte: String
  vaultAccount_in: [String!]
  vaultAccount_lt: String
  vaultAccount_lte: String
  vaultAccount_not: String
  vaultAccount_not_contains: String
  vaultAccount_not_contains_nocase: String
  vaultAccount_not_ends_with: String
  vaultAccount_not_ends_with_nocase: String
  vaultAccount_not_in: [String!]
  vaultAccount_not_starts_with: String
  vaultAccount_not_starts_with_nocase: String
  vaultAccount_starts_with: String
  vaultAccount_starts_with_nocase: String
  vault_: Vault_filter
  vault_contains: String
  vault_contains_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_gt: String
  vault_gte: String
  vault_in: [String!]
  vault_lt: String
  vault_lte: String
  vault_not: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_not_in: [String!]
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
}

enum VaultRewardPaidTransaction_orderBy {
  hash
  id
  reward
  rewardData
  timestamp
  vault
  vaultAccount
}

interface VaultTransaction {
  hash: Bytes!
  id: ID!
  timestamp: Int!
  vault: Vault!
  vaultAccount: VaultAccount!
}

input VaultTransaction_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  hash: Bytes
  hash_contains: Bytes
  hash_in: [Bytes!]
  hash_not: Bytes
  hash_not_contains: Bytes
  hash_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  vault: String
  vaultAccount: String
  vaultAccount_: VaultAccount_filter
  vaultAccount_contains: String
  vaultAccount_contains_nocase: String
  vaultAccount_ends_with: String
  vaultAccount_ends_with_nocase: String
  vaultAccount_gt: String
  vaultAccount_gte: String
  vaultAccount_in: [String!]
  vaultAccount_lt: String
  vaultAccount_lte: String
  vaultAccount_not: String
  vaultAccount_not_contains: String
  vaultAccount_not_contains_nocase: String
  vaultAccount_not_ends_with: String
  vaultAccount_not_ends_with_nocase: String
  vaultAccount_not_in: [String!]
  vaultAccount_not_starts_with: String
  vaultAccount_not_starts_with_nocase: String
  vaultAccount_starts_with: String
  vaultAccount_starts_with_nocase: String
  vault_: Vault_filter
  vault_contains: String
  vault_contains_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_gt: String
  vault_gte: String
  vault_in: [String!]
  vault_lt: String
  vault_lte: String
  vault_not: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_not_in: [String!]
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
}

enum VaultTransaction_orderBy {
  hash
  id
  timestamp
  vault
  vaultAccount
}

type VaultWithdrawTransaction implements VaultTransaction {
  assets: BigInt!
  hash: Bytes!
  id: ID!
  owner: Bytes!
  receiver: Bytes!
  sender: Bytes!
  shares: BigInt!
  timestamp: Int!
  vault: Vault!
  vaultAccount: VaultAccount!
}

input VaultWithdrawTransaction_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  assets: BigInt
  assets_gt: BigInt
  assets_gte: BigInt
  assets_in: [BigInt!]
  assets_lt: BigInt
  assets_lte: BigInt
  assets_not: BigInt
  assets_not_in: [BigInt!]
  hash: Bytes
  hash_contains: Bytes
  hash_in: [Bytes!]
  hash_not: Bytes
  hash_not_contains: Bytes
  hash_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  owner: Bytes
  owner_contains: Bytes
  owner_in: [Bytes!]
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  receiver: Bytes
  receiver_contains: Bytes
  receiver_in: [Bytes!]
  receiver_not: Bytes
  receiver_not_contains: Bytes
  receiver_not_in: [Bytes!]
  sender: Bytes
  sender_contains: Bytes
  sender_in: [Bytes!]
  sender_not: Bytes
  sender_not_contains: Bytes
  sender_not_in: [Bytes!]
  shares: BigInt
  shares_gt: BigInt
  shares_gte: BigInt
  shares_in: [BigInt!]
  shares_lt: BigInt
  shares_lte: BigInt
  shares_not: BigInt
  shares_not_in: [BigInt!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  vault: String
  vaultAccount: String
  vaultAccount_: VaultAccount_filter
  vaultAccount_contains: String
  vaultAccount_contains_nocase: String
  vaultAccount_ends_with: String
  vaultAccount_ends_with_nocase: String
  vaultAccount_gt: String
  vaultAccount_gte: String
  vaultAccount_in: [String!]
  vaultAccount_lt: String
  vaultAccount_lte: String
  vaultAccount_not: String
  vaultAccount_not_contains: String
  vaultAccount_not_contains_nocase: String
  vaultAccount_not_ends_with: String
  vaultAccount_not_ends_with_nocase: String
  vaultAccount_not_in: [String!]
  vaultAccount_not_starts_with: String
  vaultAccount_not_starts_with_nocase: String
  vaultAccount_starts_with: String
  vaultAccount_starts_with_nocase: String
  vault_: Vault_filter
  vault_contains: String
  vault_contains_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_gt: String
  vault_gte: String
  vault_in: [String!]
  vault_lt: String
  vault_lte: String
  vault_not: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_not_in: [String!]
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
}

enum VaultWithdrawTransaction_orderBy {
  assets
  hash
  id
  owner
  receiver
  sender
  shares
  timestamp
  vault
  vaultAccount
}

input Vault_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  accounts_: VaultAccount_filter
  asset: String
  asset_: Token_filter
  asset_contains: String
  asset_contains_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_gt: String
  asset_gte: String
  asset_in: [String!]
  asset_lt: String
  asset_lte: String
  asset_not: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_not_in: [String!]
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  decimals: Int
  decimals_gt: Int
  decimals_gte: Int
  decimals_in: [Int!]
  decimals_lt: Int
  decimals_lte: Int
  decimals_not: Int
  decimals_not_in: [Int!]
  depositTransactions_: VaultDepositTransaction_filter
  harvestTransactions_: VaultHarvestTransaction_filter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  name: String
  name_contains: String
  name_contains_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  rewardData_: VaultRewardData_filter
  rewardPaidTransactions_: VaultRewardPaidTransaction_filter
  strategy: Bytes
  strategy_contains: Bytes
  strategy_in: [Bytes!]
  strategy_not: Bytes
  strategy_not_contains: Bytes
  strategy_not_in: [Bytes!]
  symbol: String
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  totalSupply: BigInt
  totalSupply_gt: BigInt
  totalSupply_gte: BigInt
  totalSupply_in: [BigInt!]
  totalSupply_lt: BigInt
  totalSupply_lte: BigInt
  totalSupply_not: BigInt
  totalSupply_not_in: [BigInt!]
  totalUnderlying: BigInt
  totalUnderlying_gt: BigInt
  totalUnderlying_gte: BigInt
  totalUnderlying_in: [BigInt!]
  totalUnderlying_lt: BigInt
  totalUnderlying_lte: BigInt
  totalUnderlying_not: BigInt
  totalUnderlying_not_in: [BigInt!]
  underlying: String
  underlying_: Token_filter
  underlying_contains: String
  underlying_contains_nocase: String
  underlying_ends_with: String
  underlying_ends_with_nocase: String
  underlying_gt: String
  underlying_gte: String
  underlying_in: [String!]
  underlying_lt: String
  underlying_lte: String
  underlying_not: String
  underlying_not_contains: String
  underlying_not_contains_nocase: String
  underlying_not_ends_with: String
  underlying_not_ends_with_nocase: String
  underlying_not_in: [String!]
  underlying_not_starts_with: String
  underlying_not_starts_with_nocase: String
  underlying_starts_with: String
  underlying_starts_with_nocase: String
  withdrawTransactions_: VaultWithdrawTransaction_filter
}

enum Vault_orderBy {
  accounts
  asset
  decimals
  depositTransactions
  harvestTransactions
  id
  name
  rewardData
  rewardPaidTransactions
  strategy
  symbol
  totalSupply
  totalUnderlying
  underlying
  withdrawTransactions
}

type _Block_ {
  """
  The hash of the block
  """
  hash: Bytes

  """
  The block number
  """
  number: Int!

  """
  Integer representation of the timestamp stored in blocks for the chain
  """
  timestamp: Int
}

"""
The type for the top-level _meta field
"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  """
  block: _Block_!

  """
  The deployment ID
  """
  deployment: String!

  """
  If `true`, the subgraph encountered indexing errors at some past block
  """
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """
  Data will be returned even if the subgraph has indexing errors
  """
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}
